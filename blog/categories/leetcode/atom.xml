<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-08-14T12:09:41+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Binary Tree Zigzag Level Order Traversal]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/14/binary-tree-zigzag-level-order-traversal/"/>
    <updated>2014-08-14T11:38:34+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/14/binary-tree-zigzag-level-order-traversal</id>
    <content type="html"><![CDATA[<blockquote><p>Given a binary tree, return the zigzag level order traversal of its nodes&#8217; values. (ie, from left to right, then right to left for the next level and alternate between).</p></blockquote>

<p>For example:</p>

<p>Given binary tree {3,9,20,#,#,15,7},</p>

<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre>

<p>return its zigzag level order traversal as:</p>

<pre><code>[
  [3],
  [20,9],
  [15,7]
]
</code></pre>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">leetcode 传送门</a></p>

<p><em>思路</em></p>

<p>层序遍历，奇数层将遍历本层结点得到的vector逆置以下再加入结果vector中</p>

<pre><code>/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; zigzagLevelOrder(TreeNode *root) {
        vector&lt;vector&lt;int&gt; &gt; ret;
        if(!root) return ret;
        vector&lt;TreeNode *&gt; nodes;
        vector&lt;int&gt; nums;
        nodes.push_back(root);
        int cur = 0;
        int last = 1;
        bool oddlevel = true;
        while(cur &lt; nodes.size())
        {
            last = nodes.size();
            while(cur &lt; last)
            {
                nums.push_back(nodes[cur]-&gt;val);
                 if(nodes[cur]-&gt;right)
                    nodes.push_back(nodes[cur]-&gt;right);
                     if(nodes[cur]-&gt;left)
                    nodes.push_back(nodes[cur]-&gt;left);
                cur++;
            }
            if(oddlevel)
                reverse(nums.begin(),nums.end());
            oddlevel = !oddlevel;
            ret.push_back(nums);
            nums.clear();

        }
        return ret;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Minimum Depth of Binary Tree]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/13/minimum-depth-of-binary-tree/"/>
    <updated>2014-08-13T22:12:30+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/13/minimum-depth-of-binary-tree</id>
    <content type="html"><![CDATA[<blockquote><p>Given a binary tree, find its minimum depth.</p>

<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/minimum-depth-of-binary-tree/">leetcode 传送门</a></p>

<p><em>思路解析</em></p>

<p>深度优先遍历二叉树，每遍历一层就对depth+1，如果遇到结点是叶子结点就直接返回，如果先遍历到空结点，则这个空节点这一侧不存在子树，用<code>INT_MAX</code>标记其为不可能。递归地去左右子树中找最小值。</p>

<p>思路比较简单，但是做了挺长时间，dfs还得加强。</p>

<p><code>show your my code</code></p>

<pre><code class="c++">/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode *root) {
        if(!root) return 0;
        int depth = 1;
        return dfs(root); 
    }

    int dfs(TreeNode *root, int depth = 1)
    {
        if(!root) return INT_MAX;
        if(!root-&gt;left &amp;&amp; !root-&gt;right)
            return depth;
        depth++;
        return  min(dfs(root-&gt;left,depth),dfs(root-&gt;right,depth));

    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reverse Words in a String]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/13/reverse-words-in-a-string/"/>
    <updated>2014-08-13T13:09:26+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/13/reverse-words-in-a-string</id>
    <content type="html"><![CDATA[<blockquote><p>Given an input string, reverse the string word by word.</p>

<p>For example,</p>

<p>Given s = &ldquo;the sky is blue&rdquo;,</p>

<p>return &ldquo;blue is sky the&rdquo;.</p></blockquote>

<!--more-->


<blockquote><p>Clarification:
What constitutes a word?
A sequence of non-space characters constitutes a word.
Could the input string contain leading or trailing spaces?
Yes. However, your reversed string should not contain leading or trailing spaces.
How about multiple spaces between two words?
Reduce them to a single space in the reversed string.</p></blockquote>

<p><a href="https://oj.leetcode.com/problems/reverse-words-in-a-string/">leetcode 传送门</a></p>

<p><em>题目解析</em></p>

<p>本来是一个不难的题目，但是做了好久，关于去除多余空格的部分想复杂了，最后参考了一名CSDN的<a href="http://blog.csdn.net/kenden23/article/details/20701069">高手的博客</a>，感觉比较巧妙的地方是从后向前遍历，这样省去了不必要的操作（比如讲整个字符串逆置）。</p>

<pre><code class="c++">class Solution {
public:

    void reverseWords(string &amp;s) {
       string ret;
       for(int i=s.length()-1; i&gt;=0;)
       {
           while(i&gt;=0 &amp;&amp; s[i] == ' ')
                --i;
            if(i &lt; 0)
                break;
            if(!ret.empty()) ret.push_back(' ');
            string t;
            while(i&gt;=0 &amp;&amp; s[i] != ' ')
            {
                t+=s[i];
                --i;
            }
            reverse(t.begin(),t.end());
            ret+=t;
       }
       s = ret;
    }
};
</code></pre>

<p>剑指offer上有一题是逆置字符串单词，但是没有考虑字符串本身空格不正确的情况，假设给定的字符串是正确的英文句子（单词间有空格），书上给出的做法是先整个字符串逆置，再去从头遍历，逆置每个单词，经过两次逆置得到结果。以上方法完爆 剑指OFFER</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates from Sorted List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/13/remove-duplicates-from-sorted-list/"/>
    <updated>2014-08-13T10:55:33+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/13/remove-duplicates-from-sorted-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>

<p>For example,</p>

<p>Given 1->1->2, return 1->2.</p>

<p>Given 1->1->2->3->3, return 1->2->3.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/">leetcode 传送门</a></p>

<p>这题比较简单，直接上代码</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        if(head==NULL || head-&gt;next == NULL ) return head;
        ListNode *p = head;
        ListNode *q =p-&gt;next;

        while(q)
        {
            if(p-&gt;val == q-&gt;val)
            {
                ListNode *tmp = q;
                q=q-&gt;next;
                delete(tmp);
                p-&gt;next = q;
            }
            else
            {
                p = q;
                q= q-&gt;next;
            }
        }
        return head;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spiral Matrix II]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/spiral-matrix-ii/"/>
    <updated>2014-08-10T22:15:15+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/spiral-matrix-ii</id>
    <content type="html"><![CDATA[<blockquote><p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>

<p>For example,
Given n = 3,</p>

<p>You should return the following matrix:</p></blockquote>

<pre><code>[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</code></pre>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/spiral-matrix-ii/">leetcode 传送</a></p>

<hr />

<p><em>思路</em>
主要是坐标的计算，在矩阵上比划下，就很清晰了，没有什么算法思想</p>

<pre><code class="c++">class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) {
        int level = 0;
        vector&lt;vector&lt;int&gt; &gt;matrix(n,vector&lt;int&gt;(n,0));

        int num = 1;
        while(num &lt;= n*n)
        {
            for(int i = level; i&lt; n-level; ++i)
                matrix[level][i] = num++;
            for(int i = level+1; i&lt;n-level;++i)
                matrix[i][n-level-1] = num++;
            for(int i = n-2-level; i&gt;=level;--i)
                matrix[n-1-level][i] = num++;
            for(int i = n-2-level; i&gt;level; --i)
                matrix[i][level] = num++;
            level++;
        }
            return matrix;

    }

};
</code></pre>
]]></content>
  </entry>
  
</feed>
