<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-08-17T17:44:37+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Length of Last Word]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/17/length-of-last-word/"/>
    <updated>2014-08-17T17:24:22+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/17/length-of-last-word</id>
    <content type="html"><![CDATA[<blockquote><p>Given a string s consists of upper/lower-case alphabets and empty space characters &lsquo; &rsquo;, return the length of last word in the string.</p>

<p>If the last word does not exist, return 0.</p>

<p>Note: A word is defined as a character sequence consists of non-space characters only.</p>

<p>For example,</p>

<p>Given s = &ldquo;Hello World&rdquo;,</p>

<p>return 5.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/length-of-last-word/">leetcode express</a></p>

<p><em>思路</em></p>

<h3>method 1</h3>

<p>从后向前遍历，用strlen函数获取 char数组长度，具体实现如下：</p>

<pre><code class="c++ method 1  8 ms ">class Solution {
public:
    int lengthOfLastWord(const char *s) {
        int i = strlen(s)-1;
        int len=0;

        while(i &gt;= 0 &amp;&amp; s[i] == ' ')
            i--;
        while(i &gt;= 0 &amp;&amp; s[i] != ' ')
        {
            i--;
            len++;
        }

        return len;
    }
};
</code></pre>

<h3>method 2</h3>

<p>从头开始遍历</p>

<ul>
<li>如果当前字符不为空len++</li>
<li>如果当前节点为空，而下一个节点不为空，将len重置为0</li>
</ul>


<pre><code class="c++ method 2 32ms">class Solution {
public:
    int lengthOfLastWord(const char *s) {
        int len = 0;
        while (*s) {
            if (*s++ != ' ')
                ++len;
            else if (*s &amp;&amp; *s != ' ')
                len = 0;

        }
        return len;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reorder List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/17/reorder-list/"/>
    <updated>2014-08-17T16:32:11+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/17/reorder-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a singly linked list L: <code>L0→L1→…→Ln-1→Ln,</code></p>

<p>reorder it to: <code>L0→Ln→L1→Ln-1→L2→Ln-2→…</code></p>

<p>You must do this in-place without altering the nodes&#8217; values.</p>

<p>For example,
Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/reorder-list/">leetcode express</a></p>

<p><em>思路</em></p>

<p> 这题的难度在于问题的规模上，需要把一个字符串划分成两个字符串（快慢指针），将第二个字符串（后半个）逆置（原地逆置，头插法），再将两个字符串合并。代码如下.
 
&#8220;`c++ Reorder List</p>

<p>/<em><em>
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode </em>next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 </em>/
class Solution {
public:
    ListNode<em> findHalfNode(ListNode </em>head)
    {
        ListNode <em>fast = head;
        ListNode </em>slow = head;</p>

<pre><code>    while(fast &amp;&amp; fast-&gt;next)
    {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }
    return slow;
}

ListNode* reverseList(ListNode *head)
{
    ListNode *dummy = new ListNode(-1);
    dummy-&gt;next = head;

    ListNode *cur = head-&gt;next;
    head-&gt;next = NULL;
    while(cur)
    {
        ListNode *tmp = cur;
        cur =cur-&gt;next;
        tmp-&gt;next = dummy-&gt;next;
        dummy-&gt;next = tmp;
    }
    head = dummy-&gt;next;
    delete(dummy);
    return head;
}

void mergeTwoList(ListNode *first, ListNode *second)
{
    ListNode *pFir = first;
    ListNode *pSec = second;

    while(pSec)
    {
        ListNode *tmp = pSec;
        pSec = pSec-&gt;next;
        tmp-&gt;next = pFir-&gt;next;
        pFir-&gt;next = tmp;
        pFir = tmp-&gt;next;
    }
}
void reorderList(ListNode *head) {
    if(!head || !head-&gt;next || !head-&gt;next-&gt;next) return;
    ListNode *sec, *fir;

    sec = findHalfNode(head);
    fir = sec;
    sec = sec-&gt;next;
    fir-&gt;next = NULL;
    fir = head;
    sec = reverseList(sec);
    mergeTwoList(fir,sec);

}
</code></pre>

<p>};</p>

<p>&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Permutations II]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/16/permutations-ii/"/>
    <updated>2014-08-16T11:18:57+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/16/permutations-ii</id>
    <content type="html"><![CDATA[<blockquote><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>

<p>For example,</p>

<p>[1,1,2] have the following unique permutations:</p>

<p>[1,1,2], [1,2,1], and [2,1,1].</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/permutations-ii/">leetcode传送门</a></p>

<p><em>思路</em></p>

<p>用回溯法，求全排列的顺序同permutation</p>

<p>permutation</p>

<ol>
<li>首先固定首位元素，从第二位开始依次与第一位交换</li>
<li>对去除首位的子序列，进行全排列。同样固定子序列的首位元素，从子序列的第二位起，依次与第一位交换。</li>
<li>交换到最后一位，将此时的序列打印，递归返回。</li>
</ol>


<p>permutation II 有重复数字，所以和相同的数字交换位置，就会得到重复的序列，通过一个无序集保存当前已经交换个位置的数，如果要交换位置的数已经在无序集中，就不交换进入下一个循环</p>

<pre><code class="c++ permutation II">class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp;num) {
       vector&lt;vector&lt;int&gt; &gt; ret;
       if(num.size() &lt; 2)
       {
           ret.push_back(num);
           return ret;
       }

       perm(num,ret,0);
       return ret;
    }

    void perm(vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt; &gt; &amp;ret, int t)
    {
        if(t == num.size())
        {
            ret.push_back(num);
            return;
        }

        unordered_set&lt;int&gt; used;
        for(int i=t; i&lt; num.size(); ++i)
        {
            if(used.find(num[i]) == used.end())
            {
                swap(num[t],num[i]);
                perm(num,ret,t+1);
                swap(num[t],num[i]);
                used.insert(num[i]);
            }
        }
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Combinations]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/15/combinations/"/>
    <updated>2014-08-15T21:00:47+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/15/combinations</id>
    <content type="html"><![CDATA[<blockquote><p>Given two integers n and k, return all possible combinations of k numbers out of 1 &hellip; n.</p>

<p>For example,
If n = 4 and k = 2, a solution is:</p></blockquote>

<pre><code>[
    [2,4],
    [3,4],
    [2,3],
    [1,2],
    [1,3],
    [1,4],
]
</code></pre>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/combinations/">leetcode传送门</a></p>

<p><em>思路</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binary Tree Zigzag Level Order Traversal]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/14/binary-tree-zigzag-level-order-traversal/"/>
    <updated>2014-08-14T11:38:34+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/14/binary-tree-zigzag-level-order-traversal</id>
    <content type="html"><![CDATA[<blockquote><p>Given a binary tree, return the zigzag level order traversal of its nodes&#8217; values. (ie, from left to right, then right to left for the next level and alternate between).</p></blockquote>

<!--more-->


<blockquote><p>For example:</p>

<p>Given binary tree {3,9,20,#,#,15,7},</p></blockquote>

<pre><code>    3
   / \
  9  20
 /     \
15      7
</code></pre>

<p>return its zigzag level order traversal as:</p>

<pre><code>[
  [3],  
  [20,9],  
  [15,7]  
]
</code></pre>

<p><a href="https://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">leetcode 传送门</a></p>

<p><em>思路</em></p>

<p>层序遍历，奇数层将遍历本层结点得到的vector逆置以下再加入结果vector中</p>

<pre><code class="c++">/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; zigzagLevelOrder(TreeNode *root) {
        vector&lt;vector&lt;int&gt; &gt; ret;
        if(!root) return ret;
        vector&lt;TreeNode *&gt; nodes;
        vector&lt;int&gt; nums;
        nodes.push_back(root);
        int cur = 0;
        int last = 1;
        bool oddlevel = true;
        while(cur &lt; nodes.size())
        {
            last = nodes.size();
            while(cur &lt; last)
            {
                nums.push_back(nodes[cur]-&gt;val);
                 if(nodes[cur]-&gt;right)
                    nodes.push_back(nodes[cur]-&gt;right);
                     if(nodes[cur]-&gt;left)
                    nodes.push_back(nodes[cur]-&gt;left);
                cur++;
            }
            if(oddlevel)
                reverse(nums.begin(),nums.end());
            oddlevel = !oddlevel;
            ret.push_back(nums);
            nums.clear();

        }
        return ret;
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
