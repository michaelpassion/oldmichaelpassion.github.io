<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-08-26T10:27:15+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Unique Binary Search Trees]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/25/unique-binary-search-trees/"/>
    <updated>2014-08-25T20:17:26+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/25/unique-binary-search-trees</id>
    <content type="html"><![CDATA[<blockquote><p>Given n, how many structurally unique BST&rsquo;s (binary search trees) that store values 1&hellip;n?</p>

<p>For example,</p>

<p>Given n = 3, there are a total of 5 unique BST&rsquo;s.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/unique-binary-search-trees/">leetcode express</a></p>

<p><em>思路</em><br/>
二叉搜索树分为左子树，根，右子树。而每一个左子树又可继续划分为以上结构。同理右子树也可以进行同样的划分。使用一个数组来记录n个节点的二叉搜索树有多少种。后面使用时直接查询即可。</p>

<p>依次把每个节点作为根节点，左边节点作为左子树，右边节点作为右子树，那么总的数目等于左子树数目*右子树数目。</p>

<pre><code class="c++ DP">class Solution {
public:
    int numTrees(int n) {
        int array[n+1];
        memset(array,0,sizeof(array));
        array[0] = 1;

        for(int i=1; i&lt;=n; i++)
            for(int j=0;j&lt;i;j++)
                array[i] += array[j]*array[i-1-j];

        return array[n];
    }
};
</code></pre>

<p>实际上只需计算前半部分作为根节点的树的数目，然后乘以2（奇数节点还要加上中间节点作为根的二叉搜索树的数目）</p>

<pre><code class="c++ 只计算前半段划分">class Solution {
public:
    int numTrees(int n) {
        int array[n+1];
        memset(array,0,sizeof(array));
        array[0] = 1;

        for(int i=1; i&lt;=n; i++)
        {
            int tmp = i&gt;&gt;1;
            for(int j=1;j&lt;=tmp;j++)
            {
                array[i] += array[j-1]*array[i-j];
            }
            array[i] &lt;&lt;= 1;
            if(i &amp; 0x1)
                array[i] += array[tmp] * array[tmp]; 
        }

        return array[n];
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[two sum]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/25/two-sum/"/>
    <updated>2014-08-25T11:08:14+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/25/two-sum</id>
    <content type="html"><![CDATA[<blockquote><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>

<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>

<p>You may assume that each input would have exactly one solution.</p>

<p>  Input: numbers={2, 7, 11, 15}, target=9</p>

<p>  Output: index1=1, index2=2</p></blockquote>

<!--more-->


<p><em>思路</em></p>

<ol>
<li>用map存储整个vector，用vector中每个元素的值做pair的key，元素的index作为pair值，插入到map中</li>
<li>遍历数组时，从图中查找target-num[i]，利用图来降低时间复杂度 O(logN);</li>
</ol>


<pre><code class="c++ 时间复杂度 O(n), 空间复杂度O(n) ">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {
        vector&lt;int&gt; ret;
        if(numbers.size() &lt; 2) return ret;
        int i = 0, j = 0;
        map&lt;int,int&gt; nums;
        for(int i=0; i&lt; numbers.size(); i++)
        {
            nums.insert(pair&lt;int,int&gt;(numbers[i],i+1));
        }
        for(; i &lt; numbers.size(); i++)
        {
            int tmp = target - numbers[i];
            map&lt;int,int&gt;::iterator it = nums.find(tmp);
            if(it != nums.end())
            {
                int index1 = i+1;
                int index2 = it-&gt;second;
                if(index1&lt; index2)
                {
                    ret.push_back(index1);
                    ret.push_back(index2);
                    return ret;
                } 
                else if (index1 &gt; index2)
                {
                    ret.push_back(index2);
                    ret.push_back(index1);
                    return ret;
                }
            }
        }

        return ret;

    }
};
</code></pre>

<p><em>另一种解法</em></p>

<pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {
        int len = numbers.size();
        assert(len &gt;= 2);   
        vector&lt;int&gt; ret(2,0);
        map&lt;int, int&gt; mapping;
        vector&lt;long long&gt; mul(len,0);

        for(int i=0; i&lt;len; ++i)
        {
            mul[i] = (target - numbers[i]) * numbers[i];
            if(mapping[mul[i]] &gt;0)
            {
                // 排除 numbers[i] == target/2 的情况
                if(numbers[mapping[mul[i]] -1] + numbers[i] == target)
                {
                    ret[0] = mapping[mul[i]];
                    ret[1] = i+1;
                    return ret;
                }
            }
            else
            {
                mapping[mul[i]] = i+1;
            }
        }

    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Common Prefix]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/22/longest-common-prefix/"/>
    <updated>2014-08-22T20:26:21+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/22/longest-common-prefix</id>
    <content type="html"><![CDATA[<blockquote><p>Write a function to find the longest common prefix string amongst an array of strings.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/longest-common-prefix/">leetcode express</a></p>

<p><em>思路</em></p>

<ul>
<li>从vector中找到长度最短的string，作为prefix</li>
<li>依次比较每个字串，如果前缀不同，则将prefix的最后一个字符删去，继续比较</li>
</ul>


<pre><code class="c++ 时间复杂度 O(mn),空间复杂度O(1)">
class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt; &amp;strs) {
        if (strs.size() == 0)
            return "";

        //find the shortest string's index
        //to prevent performance degradation
        int _min_len_ = strs[0].size();
        int _min_len_index_ = 0;        
        for (int i = 0; i &lt; strs.size(); ++i)
        {
            if (strs[i].size() &lt; _min_len_)
            {
                _min_len_ = strs[i].size();
                _min_len_index_ = i;
            }
        }


        string prefix = strs[_min_len_index_];
        for (int i = 0; i &lt; strs.size(); ++i)
        {
            if (strs[i].find(prefix) != 0)
            {
                prefix = prefix.substr(0, prefix.size() - 1);
                --i;
            }
        }
        return prefix;

    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Nth Node From End of List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/22/remove-nth-node-from-end-of-list/"/>
    <updated>2014-08-22T18:03:53+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/22/remove-nth-node-from-end-of-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a linked list, remove the nth node from the end of list and return its head.</p>

<p>For example,</p></blockquote>

<pre><code> Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.
 After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.
</code></pre>

<blockquote><p>Note:</p>

<p>Given n will always be valid.</p>

<p>Try to do this in one pass.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/">leetcode express</a></p>

<p><em>思路</em></p>

<ul>
<li>利用快慢指针，慢指针比快指针慢<code>n-1</code>步.</li>
<li>快指针指向最后一个结点时，慢指针指向倒数第<code>n+1</code>个结点（不能直接找倒数第n个结点，不方便删除）</li>
<li>为链表加一个多余的头结点，用来处理链表只有一个结点，并且要删除这个结点。</li>
</ul>


<pre><code class="c++ 时间复杂度 O(n)，空间复杂度 O(1)">
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *removeNthFromEnd(ListNode *head, int n) {

        ListNode *dummy = new ListNode(-1);
        dummy-&gt;next = head;
        ListNode *slow = dummy;
        ListNode *fast = dummy;

        while(n &gt; 0)
        {
            fast = fast-&gt;next;
            n--;
        }

        while(fast-&gt;next)
        {
            fast = fast-&gt;next;
            slow = slow-&gt;next;
        }

        ListNode *tmp = slow-&gt;next;
        slow-&gt;next = tmp-&gt;next;
        delete(tmp);
        tmp = dummy-&gt;next;
        delete(dummy);

        return tmp;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sort list]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/20/sort-list/"/>
    <updated>2014-08-20T19:07:30+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/20/sort-list</id>
    <content type="html"><![CDATA[<blockquote><p>Sort a linked list in O(n log n) time using constant space complexity.</p></blockquote>

<p><em>解法一</em></p>

<p>用递归方法将链表分组，再将每一层的分组两两合并。</p>

<pre><code class="c++ 时间复杂度 O(n log n) , 空间复杂度 O(1)">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:

    ListNode* mergeList(ListNode *fir, ListNode *sec)
    {
        if(!fir) return sec;
        if(!sec) return fir;
       ListNode *dummy = new ListNode(-1);
       ListNode *p = dummy;

       while(fir &amp;&amp; sec)
       {
           if(fir-&gt;val &lt; sec-&gt;val)
           {
               p-&gt;next = fir;
               fir = fir-&gt;next;
           }
           else 
           {
               p-&gt;next = sec;
               sec = sec-&gt;next;
           }
           p = p-&gt;next;
       }

       if(!fir) 
            p-&gt;next = sec;
       else
            p-&gt;next = fir;

        p=dummy-&gt;next;
        delete(dummy);
        return p;
    }

    ListNode *sortList(ListNode *head) {
        if(!head || !head-&gt;next) return head;
        ListNode *slow = head, *fast = head;

        // 防止指针越界
        while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)
        {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        fast = slow;
        slow = slow-&gt;next;
        fast-&gt;next = NULL;

        fast = sortList(head);
        slow = sortList(slow);

        return mergeList(fast,slow);
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
