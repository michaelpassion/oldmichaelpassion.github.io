<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-08-16T11:37:19+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Permutations II]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/16/permutations-ii/"/>
    <updated>2014-08-16T11:18:57+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/16/permutations-ii</id>
    <content type="html"><![CDATA[<blockquote><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>

<p>For example,</p>

<p>[1,1,2] have the following unique permutations:</p>

<p>[1,1,2], [1,2,1], and [2,1,1].</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/permutations-ii/">leetcode传送门</a></p>

<p><em>思路</em></p>

<p>用回溯法，求全排列的顺序同permutation</p>

<p>permutation</p>

<ol>
<li>首先固定首位元素，从第二位开始依次与第一位交换</li>
<li>对去除首位的子序列，进行全排列。同样固定子序列的首位元素，从子序列的第二位起，依次与第一位交换。</li>
<li>交换到最后一位，将此时的序列打印，递归返回。</li>
</ol>


<p>permutation II 有重复数字，所以和相同的数字交换位置，就会得到重复的序列，通过一个无序集保存当前已经交换个位置的数，如果要交换位置的数已经在无序集中，就不交换进入下一个循环</p>

<pre><code class="c++ permutation II">class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; permuteUnique(vector&lt;int&gt; &amp;num) {
       vector&lt;vector&lt;int&gt; &gt; ret;
       if(num.size() &lt; 2)
       {
           ret.push_back(num);
           return ret;
       }

       perm(num,ret,0);
       return ret;
    }

    void perm(vector&lt;int&gt; &amp;num, vector&lt;vector&lt;int&gt; &gt; &amp;ret, int t)
    {
        if(t == num.size())
        {
            ret.push_back(num);
            return;
        }

        unordered_set&lt;int&gt; used;
        for(int i=t; i&lt; num.size(); ++i)
        {
            if(used.find(num[i]) == used.end())
            {
                swap(num[t],num[i]);
                perm(num,ret,t+1);
                swap(num[t],num[i]);
                used.insert(num[i]);
            }
        }
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Combinations]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/15/combinations/"/>
    <updated>2014-08-15T21:00:47+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/15/combinations</id>
    <content type="html"><![CDATA[<blockquote><p>Given two integers n and k, return all possible combinations of k numbers out of 1 &hellip; n.</p>

<p>For example,
If n = 4 and k = 2, a solution is:</p></blockquote>

<pre><code>[
    [2,4],
    [3,4],
    [2,3],
    [1,2],
    [1,3],
    [1,4],
]
</code></pre>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/combinations/">leetcode传送门</a></p>

<p><em>思路</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binary Tree Zigzag Level Order Traversal]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/14/binary-tree-zigzag-level-order-traversal/"/>
    <updated>2014-08-14T11:38:34+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/14/binary-tree-zigzag-level-order-traversal</id>
    <content type="html"><![CDATA[<blockquote><p>Given a binary tree, return the zigzag level order traversal of its nodes&#8217; values. (ie, from left to right, then right to left for the next level and alternate between).</p></blockquote>

<!--more-->


<blockquote><p>For example:</p>

<p>Given binary tree {3,9,20,#,#,15,7},</p></blockquote>

<pre><code>    3
   / \
  9  20
 /     \
15      7
</code></pre>

<p>return its zigzag level order traversal as:</p>

<pre><code>[
  [3],  
  [20,9],  
  [15,7]  
]
</code></pre>

<p><a href="https://oj.leetcode.com/problems/binary-tree-zigzag-level-order-traversal/">leetcode 传送门</a></p>

<p><em>思路</em></p>

<p>层序遍历，奇数层将遍历本层结点得到的vector逆置以下再加入结果vector中</p>

<pre><code class="c++">/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; zigzagLevelOrder(TreeNode *root) {
        vector&lt;vector&lt;int&gt; &gt; ret;
        if(!root) return ret;
        vector&lt;TreeNode *&gt; nodes;
        vector&lt;int&gt; nums;
        nodes.push_back(root);
        int cur = 0;
        int last = 1;
        bool oddlevel = true;
        while(cur &lt; nodes.size())
        {
            last = nodes.size();
            while(cur &lt; last)
            {
                nums.push_back(nodes[cur]-&gt;val);
                 if(nodes[cur]-&gt;right)
                    nodes.push_back(nodes[cur]-&gt;right);
                     if(nodes[cur]-&gt;left)
                    nodes.push_back(nodes[cur]-&gt;left);
                cur++;
            }
            if(oddlevel)
                reverse(nums.begin(),nums.end());
            oddlevel = !oddlevel;
            ret.push_back(nums);
            nums.clear();

        }
        return ret;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Minimum Depth of Binary Tree]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/13/minimum-depth-of-binary-tree/"/>
    <updated>2014-08-13T22:12:30+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/13/minimum-depth-of-binary-tree</id>
    <content type="html"><![CDATA[<blockquote><p>Given a binary tree, find its minimum depth.</p>

<p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/minimum-depth-of-binary-tree/">leetcode 传送门</a></p>

<p><em>思路解析</em></p>

<p>深度优先遍历二叉树，每遍历一层就对depth+1，如果遇到结点是叶子结点就直接返回，如果先遍历到空结点，则这个空节点这一侧不存在子树，用<code>INT_MAX</code>标记其为不可能。递归地去左右子树中找最小值。</p>

<p>思路比较简单，但是做了挺长时间，dfs还得加强。</p>

<p><code>show your my code</code></p>

<pre><code class="c++">/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode *root) {
        if(!root) return 0;
        int depth = 1;
        return dfs(root); 
    }

    int dfs(TreeNode *root, int depth = 1)
    {
        if(!root) return INT_MAX;
        if(!root-&gt;left &amp;&amp; !root-&gt;right)
            return depth;
        depth++;
        return  min(dfs(root-&gt;left,depth),dfs(root-&gt;right,depth));

    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reverse Words in a String]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/13/reverse-words-in-a-string/"/>
    <updated>2014-08-13T13:09:26+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/13/reverse-words-in-a-string</id>
    <content type="html"><![CDATA[<blockquote><p>Given an input string, reverse the string word by word.</p>

<p>For example,</p>

<p>Given s = &ldquo;the sky is blue&rdquo;,</p>

<p>return &ldquo;blue is sky the&rdquo;.</p></blockquote>

<!--more-->


<blockquote><p>Clarification:
What constitutes a word?
A sequence of non-space characters constitutes a word.
Could the input string contain leading or trailing spaces?
Yes. However, your reversed string should not contain leading or trailing spaces.
How about multiple spaces between two words?
Reduce them to a single space in the reversed string.</p></blockquote>

<p><a href="https://oj.leetcode.com/problems/reverse-words-in-a-string/">leetcode 传送门</a></p>

<p><em>题目解析</em></p>

<p>本来是一个不难的题目，但是做了好久，关于去除多余空格的部分想复杂了，最后参考了一名CSDN的<a href="http://blog.csdn.net/kenden23/article/details/20701069">高手的博客</a>，感觉比较巧妙的地方是从后向前遍历，这样省去了不必要的操作（比如讲整个字符串逆置）。</p>

<pre><code class="c++">class Solution {
public:

    void reverseWords(string &amp;s) {
       string ret;
       for(int i=s.length()-1; i&gt;=0;)
       {
           while(i&gt;=0 &amp;&amp; s[i] == ' ')
                --i;
            if(i &lt; 0)
                break;
            if(!ret.empty()) ret.push_back(' ');
            string t;
            while(i&gt;=0 &amp;&amp; s[i] != ' ')
            {
                t+=s[i];
                --i;
            }
            reverse(t.begin(),t.end());
            ret+=t;
       }
       s = ret;
    }
};
</code></pre>

<p>剑指offer上有一题是逆置字符串单词，但是没有考虑字符串本身空格不正确的情况，假设给定的字符串是正确的英文句子（单词间有空格），书上给出的做法是先整个字符串逆置，再去从头遍历，逆置每个单词，经过两次逆置得到结果。以上方法完爆 剑指OFFER</p>
]]></content>
  </entry>
  
</feed>
