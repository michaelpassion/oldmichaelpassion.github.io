<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-08-13T13:28:06+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Reverse Words in a String]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/13/reverse-words-in-a-string/"/>
    <updated>2014-08-13T13:09:26+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/13/reverse-words-in-a-string</id>
    <content type="html"><![CDATA[<blockquote><p>Given an input string, reverse the string word by word.</p>

<p>For example,</p>

<p>Given s = &ldquo;the sky is blue&rdquo;,</p>

<p>return &ldquo;blue is sky the&rdquo;.</p></blockquote>

<!--more-->


<blockquote><p>Clarification:
What constitutes a word?
A sequence of non-space characters constitutes a word.
Could the input string contain leading or trailing spaces?
Yes. However, your reversed string should not contain leading or trailing spaces.
How about multiple spaces between two words?
Reduce them to a single space in the reversed string.</p></blockquote>

<p><a href="https://oj.leetcode.com/problems/reverse-words-in-a-string/">leetcode 传送门</a></p>

<p><em>题目解析</em></p>

<p>本来是一个不难的题目，但是做了好久，关于去除多余空格的部分想复杂了，最后参考了一名CSDN的<a href="http://blog.csdn.net/kenden23/article/details/20701069">高手的博客</a>，感觉比较巧妙的地方是从后向前遍历，这样省去了不必要的操作（比如讲整个字符串逆置）。</p>

<pre><code class="c++">class Solution {
public:

    void reverseWords(string &amp;s) {
       string ret;
       for(int i=s.length()-1; i&gt;=0;)
       {
           while(i&gt;=0 &amp;&amp; s[i] == ' ')
                --i;
            if(i &lt; 0)
                break;
            if(!ret.empty()) ret.push_back(' ');
            string t;
            while(i&gt;=0 &amp;&amp; s[i] != ' ')
            {
                t+=s[i];
                --i;
            }
            reverse(t.begin(),t.end());
            ret+=t;
       }
       s = ret;
    }
};
</code></pre>

<p>剑指offer上有一题是逆置字符串单词，但是没有考虑字符串本身空格不正确的情况，假设给定的字符串是正确的英文句子（单词间有空格），书上给出的做法是先整个字符串逆置，再去从头遍历，逆置每个单词，经过两次逆置得到结果。以上方法完爆 剑指OFFER</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates from Sorted List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/13/remove-duplicates-from-sorted-list/"/>
    <updated>2014-08-13T10:55:33+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/13/remove-duplicates-from-sorted-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>

<p>For example,</p>

<p>Given 1->1->2, return 1->2.</p>

<p>Given 1->1->2->3->3, return 1->2->3.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/">leetcode 传送门</a></p>

<p>这题比较简单，直接上代码</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        if(head==NULL || head-&gt;next == NULL ) return head;
        ListNode *p = head;
        ListNode *q =p-&gt;next;

        while(q)
        {
            if(p-&gt;val == q-&gt;val)
            {
                ListNode *tmp = q;
                q=q-&gt;next;
                delete(tmp);
                p-&gt;next = q;
            }
            else
            {
                p = q;
                q= q-&gt;next;
            }
        }
        return head;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spiral Matrix II]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/spiral-matrix-ii/"/>
    <updated>2014-08-10T22:15:15+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/spiral-matrix-ii</id>
    <content type="html"><![CDATA[<blockquote><p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>

<p>For example,
Given n = 3,</p>

<p>You should return the following matrix:</p></blockquote>

<pre><code>[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</code></pre>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/spiral-matrix-ii/">leetcode 传送</a></p>

<hr />

<p><em>思路</em>
主要是坐标的计算，在矩阵上比划下，就很清晰了，没有什么算法思想</p>

<pre><code class="c++">class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) {
        int level = 0;
        vector&lt;vector&lt;int&gt; &gt;matrix(n,vector&lt;int&gt;(n,0));

        int num = 1;
        while(num &lt;= n*n)
        {
            for(int i = level; i&lt; n-level; ++i)
                matrix[level][i] = num++;
            for(int i = level+1; i&lt;n-level;++i)
                matrix[i][n-level-1] = num++;
            for(int i = n-2-level; i&gt;=level;--i)
                matrix[n-1-level][i] = num++;
            for(int i = n-2-level; i&gt;level; --i)
                matrix[i][level] = num++;
            level++;
        }
            return matrix;

    }

};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insertion Sort List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/insertion-sort-list/"/>
    <updated>2014-08-10T19:35:54+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/insertion-sort-list</id>
    <content type="html"><![CDATA[<blockquote><p>Sort a linked list using insertion sort.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/insertion-sort-list/">leetcode 传送门</a></p>

<hr />

<p><em>思路</em>
过程比较清晰的链表操作题，一开始提交出现RE，看了下原来是</p>

<p><code>while(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val)</code> 写成了</p>

<p><code>while(p-&gt;next-&gt;val &lt; cur-&gt;val &amp;&amp; p-&gt;next)</code> 如果不先判断Node是否为空就去取值必然出现问题。</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {

        ListNode *p = head;
        if(p == NULL || p-&gt;next == NULL) return head;

        ListNode *dummy = new ListNode(-1);
        dummy-&gt;next = head;
        ListNode *cur = head-&gt;next;
        head-&gt;next = NULL;

        while(cur)
        {
            ListNode *p = dummy;
            while(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val)
            {
                p=p-&gt;next;
            }

            ListNode *tmp = cur;
            cur=cur-&gt;next;
            tmp-&gt;next = p-&gt;next;
            p-&gt;next = tmp;
        }
        return dummy-&gt;next;

    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique paths]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/unique-paths/"/>
    <updated>2014-08-10T16:56:05+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/unique-paths</id>
    <content type="html"><![CDATA[<blockquote><p>A robot is located at the top-left corner of a m x n grid (marked &lsquo;Start&rsquo; in the diagram below).</p>

<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &lsquo;Finish&rsquo; in the diagram below).</p>

<p>How many possible unique paths are there?</p>

<p>Above is a 3 x 7 grid. How many possible unique paths are there?</p>

<p>Note: m and n will be at most 100.</p></blockquote>

<!--more-->


<p><em>Method 1</em>
利用分治思想，假设矩阵A[m][n],要求A[m][n]共有多少 unique paths,可以求<br/>
A[m][n] = A[m][n-1]+ A[m-1][n] （因为只能朝下方和右方走）
还可以用一维数组直接简化二维数组
<code>c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        if (m &gt; n)
        swap(m,n);
        int map[n] = {1};
        for(int i=1; i&lt;m;++i)
        {
            for(int j=1; j&lt;m; ++j)
                map[j]+=map[j-1];
        }
    }
}
</code>
<em>Method 2</em>
DP
<code>c++
class Solution {
public:
    int uniquePaths(int m, int n) {
       if(m &lt; n)
            swap(m,n);
        int a[101][101]={0};
        for(int i=0; i&lt;m; i++)
            a[i][0] = 1;
        for(int i=1; i&lt;n; i++)
            a[0][i] = 1;
        for(int i = 1; i&lt;=m; i++)
            for(int j=1; j&lt;=n;++j)
                a[i][j]= a[i-1][j] + a[i][j-1];
        return a[m-1][n-1];
    }
};
</code></p>
]]></content>
  </entry>
  
</feed>
