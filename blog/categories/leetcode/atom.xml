<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-08-10T22:22:19+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spiral Matrix II]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/spiral-matrix-ii/"/>
    <updated>2014-08-10T22:15:15+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/spiral-matrix-ii</id>
    <content type="html"><![CDATA[<p>Given an integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</p>

<p>For example,
Given n = 3,</p>

<p>You should return the following matrix:</p>

<pre><code>[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</code></pre>

<p><a href="https://oj.leetcode.com/problems/spiral-matrix-ii/">leetcode 传送</a></p>

<hr />

<p><em>思路</em>
主要是坐标的计算，在矩阵上比划下，就很清晰了，没有什么算法思想</p>

<pre><code class="c++">class Solution {
public:
    vector&lt;vector&lt;int&gt; &gt; generateMatrix(int n) {
        int level = 0;
        vector&lt;vector&lt;int&gt; &gt;matrix(n,vector&lt;int&gt;(n,0));

        int num = 1;
        while(num &lt;= n*n)
        {
            for(int i = level; i&lt; n-level; ++i)
                matrix[level][i] = num++;
            for(int i = level+1; i&lt;n-level;++i)
                matrix[i][n-level-1] = num++;
            for(int i = n-2-level; i&gt;=level;--i)
                matrix[n-1-level][i] = num++;
            for(int i = n-2-level; i&gt;level; --i)
                matrix[i][level] = num++;
            level++;
        }
            return matrix;

    }

};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insertion Sort List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/insertion-sort-list/"/>
    <updated>2014-08-10T19:35:54+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/insertion-sort-list</id>
    <content type="html"><![CDATA[<blockquote><p>Sort a linked list using insertion sort.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/insertion-sort-list/">leetcode 传送门</a></p>

<hr />

<p><em>思路</em>
过程比较清晰的链表操作题，一开始提交出现RE，看了下原来是</p>

<p><code>while(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val)</code> 写成了</p>

<p><code>while(p-&gt;next-&gt;val &lt; cur-&gt;val &amp;&amp; p-&gt;next)</code> 如果不先判断Node是否为空就去取值必然出现问题。</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {

        ListNode *p = head;
        if(p == NULL || p-&gt;next == NULL) return head;

        ListNode *dummy = new ListNode(-1);
        dummy-&gt;next = head;
        ListNode *cur = head-&gt;next;
        head-&gt;next = NULL;

        while(cur)
        {
            ListNode *p = dummy;
            while(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val)
            {
                p=p-&gt;next;
            }

            ListNode *tmp = cur;
            cur=cur-&gt;next;
            tmp-&gt;next = p-&gt;next;
            p-&gt;next = tmp;
        }
        return dummy-&gt;next;

    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique paths]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/unique-paths/"/>
    <updated>2014-08-10T16:56:05+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/unique-paths</id>
    <content type="html"><![CDATA[<blockquote><p>A robot is located at the top-left corner of a m x n grid (marked &lsquo;Start&rsquo; in the diagram below).</p>

<p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &lsquo;Finish&rsquo; in the diagram below).</p>

<p>How many possible unique paths are there?</p>

<p>Above is a 3 x 7 grid. How many possible unique paths are there?</p>

<p>Note: m and n will be at most 100.</p></blockquote>

<!--more-->


<p><em>Method 1</em>
利用分治思想，假设矩阵A[m][n],要求A[m][n]共有多少 unique paths,可以求<br/>
A[m][n] = A[m][n-1]+ A[m-1][n] （因为只能朝下方和右方走）
还可以用一维数组直接简化二维数组
<code>c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        if (m &gt; n)
        swap(m,n);
        int map[n] = {1};
        for(int i=1; i&lt;m;++i)
        {
            for(int j=1; j&lt;m; ++j)
                map[j]+=map[j-1];
        }
    }
}
</code>
<em>Method 2</em>
DP
<code>c++
class Solution {
public:
    int uniquePaths(int m, int n) {
       if(m &lt; n)
            swap(m,n);
        int a[101][101]={0};
        for(int i=0; i&lt;m; i++)
            a[i][0] = 1;
        for(int i=1; i&lt;n; i++)
            a[0][i] = 1;
        for(int i = 1; i&lt;=m; i++)
            for(int j=1; j&lt;=n;++j)
                a[i][j]= a[i-1][j] + a[i][j-1];
        return a[m-1][n-1];
    }
};
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linked List Cycle]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/linked-list-cycle/"/>
    <updated>2014-08-10T16:53:50+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/linked-list-cycle</id>
    <content type="html"><![CDATA[<blockquote><p>Given a linked list, determine if it has a cycle in it.</p>

<p>Follow up:
Can you solve it without using extra space?
<a href="https://oj.leetcode.com/problems/linked-list-cycle/">题目地址</a></p></blockquote>

<!--more-->


<p><em>Method 1</em>
快慢指针, 如果慢指针最终追上快指针，说明有环。否则，快指针先到达链表终点说明没有环。
<img src="http://img.blog.csdn.net/20131105220928500?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NfZ3VveGlhb3podQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img" />
&#8220;`c++
/<em><em>
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode </em>next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 </em>/
class Solution {
public:
    bool hasCycle(ListNode <em>head) {
        if (head == NULL ) return false;
        ListNode </em>slow = head->next;
           if(slow == NULL)
            return false;
        ListNode *fast = head->next->next;
        while(fast != NULL &amp;&amp; slow != fast)
        {
            slow =slow->next;
            fast = fast->next ? fast->next->next : fast->next;
        }</p>

<pre><code>    if(fast != NULL)
        return true;
    else
        return false;
}
</code></pre>

<p>};
&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linked List Cycle II]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/linked-list-cycle-ii/"/>
    <updated>2014-08-10T16:52:54+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/linked-list-cycle-ii</id>
    <content type="html"><![CDATA[<blockquote><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>

<p>Follow up:
Can you solve it without using extra space?</p></blockquote>

<!--more-->


<p>寻找环的过程参考 这一篇 <a href="https://zybuluo.com/michaelpassion/note/24977">Linked List Cycle</a></p>

<p>借用一张图，其中Y点为环的入口，由上篇可知，通过快慢指针可以发现环，假设快慢指针相交于Z点，则fast指针走过的路程为 <code>a+n(b+c)+b</code>， slow指针走过的路程为<code>a+b</code>。又 fast走过的路程为 slow 的2倍，所以 <code>a+n(b+c)+b = 2(a+b)</code> 则<code>a=n(b+c)-b</code>。 将slow指针指向head，然后slow，fast指针都以1的速度移动，slow由X点走向Y点路程为<code>a</code>, fast 路程也为<code>n(b+c)-b</code>在Y点（如果没有-b，fast指针绕了n圈又回到Z点）
<img src="http://images.cnitblog.com/blog/354747/201311/05171805-64db9f059a1641e7afaf3dd8223c4fe7.jpg" alt="" />
&#8220;`c++
/<em><em>
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode </em>next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 </em>/
class Solution {
public:
    ListNode <em>detectCycle(ListNode </em>head) {
        if(head == NULL) return NULL;</p>

<pre><code>    ListNode *slow = head-&gt;next;
    if (slow == NULL) return NULL;
    ListNode *fast = head-&gt;next-&gt;next;

    while(fast != NULL &amp;&amp; slow != fast)
    {
        slow = slow-&gt;next;
        fast = fast-&gt;next ? fast-&gt;next-&gt;next :fast-&gt;next;
    }

    if(!fast) return NULL;
    slow = head;
    while(slow != fast)
    {
        slow=slow-&gt;next;
        fast=fast-&gt;next;
    }
    return slow;
}
</code></pre>

<p>};
&#8220;`</p>
]]></content>
  </entry>
  
</feed>
