<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-09-11T18:00:07+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Search a 2D Matrix]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/04/search-a-2d-matrix/"/>
    <updated>2014-09-04T10:50:42+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/04/search-a-2d-matrix</id>
    <content type="html"><![CDATA[<blockquote><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>

<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>


<p>For example,</p>

<p>Consider the following matrix:</p></blockquote>

<pre><code>[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
</code></pre>

<blockquote><p>Given target = <code>3</code>, return <code>true</code>.</p></blockquote>

<!-- more-->


<p><a href="https://oj.leetcode.com/problems/search-a-2d-matrix/">leetcode express</a></p>

<p><strong>方法一</strong><br/>
先查找target可能在的行，再从行中找target</p>

<pre><code class="c++ 二分 时间复杂度 O(logm+logn)">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) {
        int row = matrix.size() - 1;
        int col = matrix[0].size() - 1;

        //注意low从1开始
        int low = 1, high = row;
        while(low &lt;= high)
        {
            int mid = low + (high - low)/2;
           if (matrix[mid - 1][col] == target)
                return true;
            else if (matrix[mid -1][col] &gt; target)
                high = mid - 1;
            else
                low = mid + 1;
        }
        row = high;
        low = 0; high = col;
        while(low &lt;= high)
        {
            int mid = (low+high)/2;
            if(matrix[row][mid] == target)
                return true;
            else if(matrix[row][mid] &gt; target)
                high = mid -1;
            else 
                low = mid + 1;
        }
        return false;
    }
};
</code></pre>

<p><strong>方法二</strong></p>

<p>这个方法还没有第一个方法好。</p>

<p>&#8220;`c++ 时间复杂度O(n*logm)
class Solution {
public:
    bool searchMatrix(vector&lt;vector<int> > &amp;matrix, int target) {
        int row = matrix.size() - 1;
        int col = matrix[0].size() - 1;</p>

<pre><code>    for(int i = 0 ; i &lt;= row;)
    {
        int tmp = matrix[i][col];
        if(matrix[i][col] == target)
            return true;
        if(matrix[i][col] &gt; target)
        {
            int l = 0, r = col;
            while(l &lt;= r)
            {
                int mid = (l+r)/2;
                if(matrix[i][mid] == target)
                    return true;
                if(matrix[i][mid] &gt; target)
                    r = mid - 1;
                else
                    l = l + 1;
            }
            return false;
        } else
        {
            i++;
        }
    }

    return false;
}
</code></pre>

<p>};
&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pow(x,y)]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/27/pow-x/"/>
    <updated>2014-08-27T23:25:37+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/27/pow-x</id>
    <content type="html"><![CDATA[<blockquote><p>Implement pow(x, n).</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/powx-n/">leetcode express</a></p>

<pre><code class="c++">class Solution {
public:
    double pow(double x, int n) {
        if(n == 0) return 1;
        if(n &lt; 0) return 1 /( x * pow( x , -n-1));
        double num1 = x, num2 = 1;
        while(n &gt; 1)
        {
            if(n &amp; 0x1) num2 *= num1;
            num1 *= num1;
            n &gt;&gt;= 2;
        }
       return num1 * num2;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[next_permutation]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/26/next-permutation/"/>
    <updated>2014-08-26T13:51:45+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/26/next-permutation</id>
    <content type="html"><![CDATA[<blockquote><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.<br/>
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).<br/>
The replacement must be in-place, do not allocate extra memory.<br/>
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p></blockquote>

<pre><code> 1,2,3 → 1,3,2 
 3,2,1 → 1,2,3 
 1,1,5 → 1,5,1
</code></pre>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/next-permutation/">leetcode express</a></p>

<p><em>思路</em></p>

<ol>
<li>从后向前扫描 <code>vector&lt;int&gt; num</code>，寻找后一个数大于前一个数的位置，标记前一个数的index 为 <code>i</code>。</li>
<li>再从后面开始扫描，寻找第一个大于下标为<code>num[i]</code>的数（必然存在，主意一定是大于没有等于符号），标记符合条件的下标为<code>j</code>,交换<code>num[i]</code> ,<code>num[j]</code>。</li>
<li>将<code>index[i]</code>后的全部数字逆置，得到结果。</li>
</ol>


<p><strong>exception</strong></p>

<ul>
<li>若当前数字排序已经是能表示的最大数字，所以符合条件的下一个字典序为所有排列中最小的数字</li>
</ul>


<pre><code class="c++">class Solution {
public:
    void nextPermutation(vector&lt;int&gt; &amp;num) {
        int n = num.size();
        if(n &lt; 2) return;

        for(int i = n-2, ii = n-1; i &gt;= 0; i--, ii--)
        {
            if(num[i] &lt; num[ii])
            {
                int j = n-1;
                while(num[j] &lt;= num[i]) 
                    j--;
                swap(num[i],num[j]);
                reverse(num.begin()+ii,num.end());
                return;
            }
        }

        reverse(num.begin(), num.end());
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique Binary Search Trees]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/25/unique-binary-search-trees/"/>
    <updated>2014-08-25T20:17:26+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/25/unique-binary-search-trees</id>
    <content type="html"><![CDATA[<blockquote><p>Given n, how many structurally unique BST&rsquo;s (binary search trees) that store values 1&hellip;n?</p>

<p>For example,</p>

<p>Given n = 3, there are a total of 5 unique BST&rsquo;s.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/unique-binary-search-trees/">leetcode express</a></p>

<p><em>思路</em><br/>
二叉搜索树分为左子树，根，右子树。而每一个左子树又可继续划分为以上结构。同理右子树也可以进行同样的划分。使用一个数组来记录n个节点的二叉搜索树有多少种。后面使用时直接查询即可。</p>

<p>依次把每个节点作为根节点，左边节点作为左子树，右边节点作为右子树，那么总的数目等于左子树数目*右子树数目。</p>

<pre><code class="c++ DP">class Solution {
public:
    int numTrees(int n) {
        int array[n+1];
        memset(array,0,sizeof(array));
        array[0] = 1;

        for(int i=1; i&lt;=n; i++)
            for(int j=0;j&lt;i;j++)
                array[i] += array[j]*array[i-1-j];

        return array[n];
    }
};
</code></pre>

<p>实际上只需计算前半部分作为根节点的树的数目，然后乘以2（奇数节点还要加上中间节点作为根的二叉搜索树的数目）</p>

<pre><code class="c++ 只计算前半段划分">class Solution {
public:
    int numTrees(int n) {
        int array[n+1];
        memset(array,0,sizeof(array));
        array[0] = 1;

        for(int i=1; i&lt;=n; i++)
        {
            int tmp = i&gt;&gt;1;
            for(int j=1;j&lt;=tmp;j++)
            {
                array[i] += array[j-1]*array[i-j];
            }
            array[i] &lt;&lt;= 1;
            if(i &amp; 0x1)
                array[i] += array[tmp] * array[tmp]; 
        }

        return array[n];
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[two sum]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/25/two-sum/"/>
    <updated>2014-08-25T11:08:14+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/25/two-sum</id>
    <content type="html"><![CDATA[<blockquote><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>

<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>

<p>You may assume that each input would have exactly one solution.</p>

<p>  Input: numbers={2, 7, 11, 15}, target=9</p>

<p>  Output: index1=1, index2=2</p></blockquote>

<!--more-->


<p><em>思路</em></p>

<ol>
<li>用map存储整个vector，用vector中每个元素的值做pair的key，元素的index作为pair值，插入到map中</li>
<li>遍历数组时，从图中查找target-num[i]，利用图来降低时间复杂度 O(logN);</li>
</ol>


<pre><code class="c++ 时间复杂度 O(n), 空间复杂度O(n) ">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {
        vector&lt;int&gt; ret;
        if(numbers.size() &lt; 2) return ret;
        int i = 0, j = 0;
        map&lt;int,int&gt; nums;
        for(int i=0; i&lt; numbers.size(); i++)
        {
            nums.insert(pair&lt;int,int&gt;(numbers[i],i+1));
        }
        for(; i &lt; numbers.size(); i++)
        {
            int tmp = target - numbers[i];
            map&lt;int,int&gt;::iterator it = nums.find(tmp);
            if(it != nums.end())
            {
                int index1 = i+1;
                int index2 = it-&gt;second;
                if(index1&lt; index2)
                {
                    ret.push_back(index1);
                    ret.push_back(index2);
                    return ret;
                } 
                else if (index1 &gt; index2)
                {
                    ret.push_back(index2);
                    ret.push_back(index1);
                    return ret;
                }
            }
        }

        return ret;

    }
};
</code></pre>

<p><em>另一种解法</em></p>

<pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {
        int len = numbers.size();
        assert(len &gt;= 2);   
        vector&lt;int&gt; ret(2,0);
        map&lt;int, int&gt; mapping;
        vector&lt;long long&gt; mul(len,0);

        for(int i=0; i&lt;len; ++i)
        {
            mul[i] = (target - numbers[i]) * numbers[i];
            if(mapping[mul[i]] &gt;0)
            {
                // 排除 numbers[i] == target/2 的情况
                if(numbers[mapping[mul[i]] -1] + numbers[i] == target)
                {
                    ret[0] = mapping[mul[i]];
                    ret[1] = i+1;
                    return ret;
                }
            }
            else
            {
                mapping[mul[i]] = i+1;
            }
        }

    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
