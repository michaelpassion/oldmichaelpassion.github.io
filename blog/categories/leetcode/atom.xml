<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-09-11T23:55:13+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Permutation Sequence]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/11/permutation-sequence/"/>
    <updated>2014-09-11T23:48:20+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/11/permutation-sequence</id>
    <content type="html"><![CDATA[<blockquote><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>

<p>By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):</p>

<ol>
<li>&ldquo;123&rdquo;</li>
<li>&ldquo;132&rdquo;</li>
<li>&ldquo;213&rdquo;</li>
<li>&ldquo;231&rdquo;</li>
<li>&ldquo;312&rdquo;</li>
<li>&ldquo;321&rdquo;</li>
</ol>


<p>Given n and k, return the k-th permutation sequence.</p>

<p>Note: Given n will be between 1 and 9 inclusive.</p></blockquote>

<pre><code class="c++ 时间复杂度O(n),空间复杂度O(1)">class Solution {
public:
    int factorial(int n)
    {
        int res = 1;
        for(int i=2 ;i&lt;=n; i++)
            res *= i;
        return res;
    }
    string getPermutation(int n, int k) {
        int total = factorial(n);
          string candidate = string("123456789").substr(0, n);
          string res(n,' ');
          for(int i = 0; i &lt; n; i++)//依次计算排列的每个位
          {
              total /= (n-i);
             int index = (k-1) / total;
             res[i] = candidate[index];
             candidate.erase(index, 1);
             k -= index*total;
         }
         return res;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Search a 2D Matrix]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/04/search-a-2d-matrix/"/>
    <updated>2014-09-04T10:50:42+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/04/search-a-2d-matrix</id>
    <content type="html"><![CDATA[<blockquote><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>

<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>


<p>For example,</p>

<p>Consider the following matrix:</p></blockquote>

<pre><code>[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
</code></pre>

<blockquote><p>Given target = <code>3</code>, return <code>true</code>.</p></blockquote>

<!-- more-->


<p><a href="https://oj.leetcode.com/problems/search-a-2d-matrix/">leetcode express</a></p>

<p><strong>方法一</strong><br/>
先查找target可能在的行，再从行中找target</p>

<pre><code class="c++ 二分 时间复杂度 O(logm+logn)">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) {
        int row = matrix.size() - 1;
        int col = matrix[0].size() - 1;

        //注意low从1开始
        int low = 1, high = row;
        while(low &lt;= high)
        {
            int mid = low + (high - low)/2;
           if (matrix[mid - 1][col] == target)
                return true;
            else if (matrix[mid -1][col] &gt; target)
                high = mid - 1;
            else
                low = mid + 1;
        }
        row = high;
        low = 0; high = col;
        while(low &lt;= high)
        {
            int mid = (low+high)/2;
            if(matrix[row][mid] == target)
                return true;
            else if(matrix[row][mid] &gt; target)
                high = mid -1;
            else 
                low = mid + 1;
        }
        return false;
    }
};
</code></pre>

<p><strong>方法二</strong></p>

<p>这个方法还没有第一个方法好。</p>

<p>&#8220;`c++ 时间复杂度O(n*logm)
class Solution {
public:
    bool searchMatrix(vector&lt;vector<int> > &amp;matrix, int target) {
        int row = matrix.size() - 1;
        int col = matrix[0].size() - 1;</p>

<pre><code>    for(int i = 0 ; i &lt;= row;)
    {
        int tmp = matrix[i][col];
        if(matrix[i][col] == target)
            return true;
        if(matrix[i][col] &gt; target)
        {
            int l = 0, r = col;
            while(l &lt;= r)
            {
                int mid = (l+r)/2;
                if(matrix[i][mid] == target)
                    return true;
                if(matrix[i][mid] &gt; target)
                    r = mid - 1;
                else
                    l = l + 1;
            }
            return false;
        } else
        {
            i++;
        }
    }

    return false;
}
</code></pre>

<p>};
&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pow(x,y)]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/27/pow-x/"/>
    <updated>2014-08-27T23:25:37+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/27/pow-x</id>
    <content type="html"><![CDATA[<blockquote><p>Implement pow(x, n).</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/powx-n/">leetcode express</a></p>

<pre><code class="c++">class Solution {
public:
    double pow(double x, int n) {
        if(n == 0) return 1;
        if(n &lt; 0) return 1 /( x * pow( x , -n-1));
        double num1 = x, num2 = 1;
        while(n &gt; 1)
        {
            if(n &amp; 0x1) num2 *= num1;
            num1 *= num1;
            n &gt;&gt;= 2;
        }
       return num1 * num2;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[next_permutation]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/26/next-permutation/"/>
    <updated>2014-08-26T13:51:45+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/26/next-permutation</id>
    <content type="html"><![CDATA[<blockquote><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.<br/>
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).<br/>
The replacement must be in-place, do not allocate extra memory.<br/>
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p></blockquote>

<pre><code> 1,2,3 → 1,3,2 
 3,2,1 → 1,2,3 
 1,1,5 → 1,5,1
</code></pre>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/next-permutation/">leetcode express</a></p>

<p><em>思路</em></p>

<ol>
<li>从后向前扫描 <code>vector&lt;int&gt; num</code>，寻找后一个数大于前一个数的位置，标记前一个数的index 为 <code>i</code>。</li>
<li>再从后面开始扫描，寻找第一个大于下标为<code>num[i]</code>的数（必然存在，主意一定是大于没有等于符号），标记符合条件的下标为<code>j</code>,交换<code>num[i]</code> ,<code>num[j]</code>。</li>
<li>将<code>index[i]</code>后的全部数字逆置，得到结果。</li>
</ol>


<p><strong>exception</strong></p>

<ul>
<li>若当前数字排序已经是能表示的最大数字，所以符合条件的下一个字典序为所有排列中最小的数字</li>
</ul>


<pre><code class="c++">class Solution {
public:
    void nextPermutation(vector&lt;int&gt; &amp;num) {
        int n = num.size();
        if(n &lt; 2) return;

        for(int i = n-2, ii = n-1; i &gt;= 0; i--, ii--)
        {
            if(num[i] &lt; num[ii])
            {
                int j = n-1;
                while(num[j] &lt;= num[i]) 
                    j--;
                swap(num[i],num[j]);
                reverse(num.begin()+ii,num.end());
                return;
            }
        }

        reverse(num.begin(), num.end());
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique Binary Search Trees]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/25/unique-binary-search-trees/"/>
    <updated>2014-08-25T20:17:26+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/25/unique-binary-search-trees</id>
    <content type="html"><![CDATA[<blockquote><p>Given n, how many structurally unique BST&rsquo;s (binary search trees) that store values 1&hellip;n?</p>

<p>For example,</p>

<p>Given n = 3, there are a total of 5 unique BST&rsquo;s.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/unique-binary-search-trees/">leetcode express</a></p>

<p><em>思路</em><br/>
二叉搜索树分为左子树，根，右子树。而每一个左子树又可继续划分为以上结构。同理右子树也可以进行同样的划分。使用一个数组来记录n个节点的二叉搜索树有多少种。后面使用时直接查询即可。</p>

<p>依次把每个节点作为根节点，左边节点作为左子树，右边节点作为右子树，那么总的数目等于左子树数目*右子树数目。</p>

<pre><code class="c++ DP">class Solution {
public:
    int numTrees(int n) {
        int array[n+1];
        memset(array,0,sizeof(array));
        array[0] = 1;

        for(int i=1; i&lt;=n; i++)
            for(int j=0;j&lt;i;j++)
                array[i] += array[j]*array[i-1-j];

        return array[n];
    }
};
</code></pre>

<p>实际上只需计算前半部分作为根节点的树的数目，然后乘以2（奇数节点还要加上中间节点作为根的二叉搜索树的数目）</p>

<pre><code class="c++ 只计算前半段划分">class Solution {
public:
    int numTrees(int n) {
        int array[n+1];
        memset(array,0,sizeof(array));
        array[0] = 1;

        for(int i=1; i&lt;=n; i++)
        {
            int tmp = i&gt;&gt;1;
            for(int j=1;j&lt;=tmp;j++)
            {
                array[i] += array[j-1]*array[i-j];
            }
            array[i] &lt;&lt;= 1;
            if(i &amp; 0x1)
                array[i] += array[tmp] * array[tmp]; 
        }

        return array[n];
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
