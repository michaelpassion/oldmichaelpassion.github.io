<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-11-14T10:14:00+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Min Stack]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/14/min-stack/"/>
    <updated>2014-11-14T10:08:06+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/14/min-stack</id>
    <content type="html"><![CDATA[<blockquote><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>

<p>push(x) &ndash; Push element x onto stack.<br/>
pop() &ndash; Removes the element on top of the stack.<br/>
top() &ndash; Get the top element.<br/>
getMin() &ndash; Retrieve the minimum element in the stack.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/min-stack/">Leetcode express</a></p>

<pre><code class="c++">class MinStack {

stack&lt;int&gt; nums;
stack&lt;int&gt; min;
public:
    void push(int x) {
        nums.push(x);
        if (min.size() == 0 || x &lt;= min.top())
            min.push(x);

    }

    void pop() {
        if (nums.top() == min.top())
            min.pop();
        nums.pop();
    }

    int top() {
        return nums.top();
    }

    int getMin() {
        return min.top();
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find Minimum in Rotated Sorted Array]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/10/17/find-minimum-in-rotated-sorted-array/"/>
    <updated>2014-10-17T21:54:04+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/10/17/find-minimum-in-rotated-sorted-array</id>
    <content type="html"><![CDATA[<blockquote><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>

<p>Find the minimum element.</p>

<p>You may assume no duplicate exists in the array.</p></blockquote>

<!--more-->


<p>leetcode 出新题了，看起来是个水题，一时技痒就写了（不害臊，打脸）(￣ε(#￣)☆╰╮(￣▽￣///)</p>

<p><strong>思路</strong><br/>
因为是旋转的有序数组，所以可以看成是两个分别有序的递增数组，又前一个数组中的值肯定大于后一个数组中的值，所以只需遍历前面数组，找到比指向后一个数组最后一个数字小的第一个数字就是整个旋转有序数组的最小值。<br/>
<em>特殊情况</em> ：如果原数组并没有旋转，那么<code>num[0] &lt; num[n-1]</code>, 直接返回<code>num[0]</code></p>

<pre><code class="c++">class Solution {
public:
    int findMin(vector&lt;int&gt; &amp;num) {
        if (num.size() &lt;= 1) return num[0];

        int l = 0, r = num.size()-1;
        while(l &lt; r)
        {
            if (num[l] &gt; num[r])
                l++;
            else
                return num[l];
        }
        return num[l];
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Word Search]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/21/word-search/"/>
    <updated>2014-09-21T13:47:52+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/21/word-search</id>
    <content type="html"><![CDATA[<blockquote><p>Given a 2D board and a word, find if the word exists in the grid.</p>

<p>The word can be constructed from letters of sequentially adjacent cell, where &ldquo;adjacent&rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>

<p>For example,<br/>
Given board =</p>

<pre><code>[
  ["ABCE"],
  ["SFCS"],
  ["ADEE"]
]   
</code></pre>

<p>word = <code>"ABCCED"</code>, -> returns <code>true</code>,<br/>
word = <code>"SEE"</code>, -> returns <code>true</code>,<br/>
word = <code>"ABCB"</code>, -> returns <code>false</code>.</p></blockquote>

<!--more-->


<p><strong>思路</strong><br/>
先在board中寻找word的首字母，找到后在该位置的相邻位置（上下左右）查看是否能生成word，如果上下左右中有位置符合条件，则继续从该位置的临近位置搜索下一个字符。主要，不能board中的字符不能重复使用，故需要将访问过的字符做标记，下面代码中设置为<code>‘#’</code>,对该位置搜索完后要恢复原来的字母。</p>

<pre><code class="c++">class Solution {
public:

    bool dfs(vector&lt;vector&lt;char&gt;&gt; &amp;board,int row, int col, string word, int index)
    {
        if (index == word.size()-1) return true;
        char ctmp = board[row][col];
        board[row][col] = '#';

        //向上查询
        if (row-1&gt;=0 &amp;&amp; board[row-1][col] == word[index+1])
            if (dfs(board,row-1,col,word,index+1))
                return true;

         //向下
        if (row+1&lt;=board.size()-1 &amp;&amp; board[row+1][col] == word[index+1])
            if (dfs(board,row+1,col,word,index+1))
                return true;
        //向左
        if (col-1 &gt;= 0 &amp;&amp; board[row][col-1] == word[index+1])
             if (dfs(board,row,col-1,word,index+1))
                return true;
        向右
        if(col+1 &lt;= board[0].size()-1 &amp;&amp; board[row][col+1] == word[index+1])
            if (dfs(board,row,col+1,word,index+1))
                return true;

        //恢复原来的字母        
        board[row][col] = ctmp;
        return false;
    }
    bool exist(vector&lt;vector&lt;char&gt; &gt; &amp;board, string word) {
        const int rows = board.size();
        const int cols = board[0].size();

        for (int i=0; i&lt;rows; i++)
        {
            for (int j=0; j&lt;cols; j++)
            {
                if (board[i][j] == word[0] &amp;&amp; dfs(board,i,j,word,0))
                    return true;
            }
        }

        return false;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rotate List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/14/rotate-list/"/>
    <updated>2014-09-14T16:08:37+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/14/rotate-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a list, rotate the list to the right by k places, where k is non-negative.<br/>
For example:
Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> and <code>k = 2</code>,<br/>
return <code>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code>.</p></blockquote>

<!--more-->


<p><strong>思路</strong><br/>
有点感冒，头晕晕乎乎的，还出冷汗，一开始脑子不够用，竟然套用翻转string的那个算法，还reverse三次，弱爆了。其次就是<code>k</code>的值可能大于链表长度，我没有去算链表长度，直接用快慢指针做的，这样对于特殊输入运行效率可能极其低下，回头修改，写完这点，回宿舍休息会去。</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *rotateRight(ListNode *head, int k) {
        if(!head || !head-&gt;next || k &lt; 1) return head;
        ListNode *p = head;
        for (int i=0; i&lt;k; i++) 
        {
            if (p-&gt;next == NULL) 
            {
                p = head;
            }
            else 
            {
                p = p-&gt;next;
            }
        }

        ListNode *q = head;
        while (p-&gt;next)
        {
            p = p-&gt;next;
            q = q-&gt;next;
        }
        p-&gt;next = head;

        ListNode *newHead = q-&gt;next;
        q-&gt;next = NULL;

        return newHead;
        }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Triangle]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/12/triangle/"/>
    <updated>2014-09-12T17:40:54+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/12/triangle</id>
    <content type="html"><![CDATA[<blockquote><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>

<p>For example, given the following triangle</p>

<pre><code>    [
         [2],       
        [3,4],  
       [6,5,7],  
      [4,1,8,3]  
    ]   
</code></pre>

<p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>

<p>Note:<br/>
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p></blockquote>

<!--more-->


<pre><code class="c++ ">
class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        int n = triangle.size();
        vector&lt;int&gt; minNums = triangle[n-1];

        for (int i = n - 2; i &gt;= 0; i--)
        {
            for(int j = 0; j &lt;= i; j++)
            {
                minNums[j] = min(minNums[j], minNums[j+1]) + triangle[i][j];
            }
        }

        return minNums[0];
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
