<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-11-19T17:45:37+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Valid Sudoku]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/19/valid-sudoku/"/>
    <updated>2014-11-19T17:38:58+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/19/valid-sudoku</id>
    <content type="html"><![CDATA[<blockquote><p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx">Sudoku Puzzles - The Rules</a>.</p>

<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>'.'</code>.<br/>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="" /></p>

<p>A partially filled sudoku which is valid.<br/>
Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p></blockquote>

<!--more-->


<p><strong>解题思路</strong><br/>
这道题要求检查数独是否有效，既检查数独里的每一行，每一列，每一个九宫格里有没有重复数字，若有，则数独是无效的。通过一个双层循环可以实现以上三种检查，难点在检查九宫格。<br/>
以下方法定义了三个数组，分别用来检查行，列，九宫格，相当于三个hash table。</p>

<pre><code>class Solution {
public:
    bool isValidSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) {
        int checkRow[10] = {0};
        int checkCol[10] = {0};
        int checkSqu[10] = {0};
        for(int i=0; i&lt; 9; ++i)
        {
            memset(checkRow,0,sizeof(checkRow));
            memset(checkCol,0,sizeof(checkCol));
            memset(checkSqu,0,sizeof(checkSqu));
            for(int j=0; j&lt; 9; ++j)
            {
               if(!checkValid(checkRow,board[i][j]-'0') || 
                  !checkValid(checkCol,board[j][i]-'0') ||
                  !checkValid (checkSqu,board[3*(i/3)+j/3][3*(i%3)+j%3]-'0'))
                  return false;

            }
        }
        return true;
    }
    bool checkValid(int a[], int val)
    {
        if (val &lt; 0) return true;
        if (a[val] == 1) return false;
        a[val] = 1;
        return true;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add Binary]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/19/add-binary/"/>
    <updated>2014-11-19T13:11:32+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/19/add-binary</id>
    <content type="html"><![CDATA[<blockquote><p>Given two binary strings, return their sum (also a binary string).</p>

<p>For example,<br/>
a = <code>"11"</code><br/>
b = <code>"1"</code><br/>
Return <code>"100"</code>.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/add-binary/">leetcode express</a></p>

<p><strong>解题思路</strong>
类似于多项式相加，用位运算加速计算，<code>carry</code>用来保存进位，<code>tmp</code>保存两个二进制数第<code>i</code>位的和，再和carry相加，并将结果加入<code>res</code>中，最后因为<code>res</code>是逆序的，再将<code>res</code>翻转一遍。<br/>
&#8220;`
class Solution {
public:
    string addBinary(string a, string b) {
        int result=0, carry =0;
        string res = &ldquo;&rdquo;;
        int aLen = a.length()-1;
        int bLen = b.length()-1;
        int tmp;</p>

<pre><code>    while(aLen &gt;=0 &amp;&amp; bLen &gt;=0)
    {
        result = (a[aLen]-'0')^(b[bLen] - '0');
        tmp = (result ^ carry);
        res +=to_string(tmp);
        carry = (a[aLen--]- '0')+(b[bLen--] - '0')+carry &gt;= 2 ? 1 : 0;
    }

    while (aLen&gt;=0) {
        tmp = ((a[aLen]-'0')^carry);
        res += to_string(tmp);
        carry = (a[aLen]-'0')&amp;carry;
        aLen--;
    }
    while (bLen&gt;=0) {
        tmp = ((b[bLen]-'0')^carry);
        res += to_string(tmp);
        carry = (b[bLen]-'0')&amp;carry;
        bLen--;
    }
    if (carry == 1) {
        res += to_string(carry);
    }

    int l =0, r= res.length()-1;
    while(l &lt; r)
    {
        swap(res[l],res[r]);
        l++;r--;
    }

    return res;
}
</code></pre>

<p>};
&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Count and Say]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/18/count-and-say/"/>
    <updated>2014-11-18T22:54:58+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/18/count-and-say</id>
    <content type="html"><![CDATA[<blockquote><p>The count-and-say sequence is the sequence of integers beginning as follows:
<code>1, 11, 21, 1211, 111221, ...</code></p>

<p><code>1</code> is read off as <code>"one 1"</code> or <code>11</code>.<br/>
<code>11</code> is read off as <code>"two 1s"</code> or<code>21</code>.<br/>
<code>21</code> is read off as <code>"one 2, then one 1"</code> or <code>1211</code>.<br/>
Given an integer <code>n</code>, generate the <code>nth</code> sequence.</p>

<p>Note: The sequence of integers will be represented as a string.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/count-and-say/">leetcode express</a></p>

<p><strong>解题思路</strong>
最开始想到递归，因为后一个字符串是通过前一个字符串确定的，但是转念一想只需要一个字符串来保存状态即可，以下解法公参考：</p>

<pre><code>class Solution {
public:
    string countAndSay(int n) {
        if (n == 1)  return "1";
        string a = "1";
        string tmp = "";
        for (int i=0; i&lt; n-1; i++) {
            int count = 1;

            for (int j=0; j&lt;a.length(); j++) {
                if(a[j] == a[j+1])
                    count++;
                else
                {
                    tmp += to_string(count) + a[j];
                    count=1;

                }
            }
            a = tmp;
            tmp = "";
        }

        return a;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Min Stack]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/14/min-stack/"/>
    <updated>2014-11-14T10:08:06+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/14/min-stack</id>
    <content type="html"><![CDATA[<blockquote><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>

<p>push(x) &ndash; Push element x onto stack.<br/>
pop() &ndash; Removes the element on top of the stack.<br/>
top() &ndash; Get the top element.<br/>
getMin() &ndash; Retrieve the minimum element in the stack.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/min-stack/">Leetcode express</a></p>

<pre><code class="c++">class MinStack {

stack&lt;int&gt; nums;
stack&lt;int&gt; min;
public:
    void push(int x) {
        nums.push(x);
        if (min.size() == 0 || x &lt;= min.top())
            min.push(x);

    }

    void pop() {
        if (nums.top() == min.top())
            min.pop();
        nums.pop();
    }

    int top() {
        return nums.top();
    }

    int getMin() {
        return min.top();
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find Minimum in Rotated Sorted Array]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/10/17/find-minimum-in-rotated-sorted-array/"/>
    <updated>2014-10-17T21:54:04+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/10/17/find-minimum-in-rotated-sorted-array</id>
    <content type="html"><![CDATA[<blockquote><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>

<p>Find the minimum element.</p>

<p>You may assume no duplicate exists in the array.</p></blockquote>

<!--more-->


<p>leetcode 出新题了，看起来是个水题，一时技痒就写了（不害臊，打脸）(￣ε(#￣)☆╰╮(￣▽￣///)</p>

<p><strong>思路</strong><br/>
因为是旋转的有序数组，所以可以看成是两个分别有序的递增数组，又前一个数组中的值肯定大于后一个数组中的值，所以只需遍历前面数组，找到比指向后一个数组最后一个数字小的第一个数字就是整个旋转有序数组的最小值。<br/>
<em>特殊情况</em> ：如果原数组并没有旋转，那么<code>num[0] &lt; num[n-1]</code>, 直接返回<code>num[0]</code></p>

<pre><code class="c++">class Solution {
public:
    int findMin(vector&lt;int&gt; &amp;num) {
        if (num.size() &lt;= 1) return num[0];

        int l = 0, r = num.size()-1;
        while(l &lt; r)
        {
            if (num[l] &gt; num[r])
                l++;
            else
                return num[l];
        }
        return num[l];
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
