<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-08-24T19:53:27+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Longest Common Prefix]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/22/longest-common-prefix/"/>
    <updated>2014-08-22T20:26:21+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/22/longest-common-prefix</id>
    <content type="html"><![CDATA[<blockquote><p>Write a function to find the longest common prefix string amongst an array of strings.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/longest-common-prefix/">leetcode express</a></p>

<p><em>思路</em></p>

<ul>
<li>从vector中找到长度最短的string，作为prefix</li>
<li>依次比较每个字串，如果前缀不同，则将prefix的最后一个字符删去，继续比较</li>
</ul>


<pre><code class="c++ 时间复杂度 O(mn),空间复杂度O(1)">
class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt; &amp;strs) {
        if (strs.size() == 0)
            return "";

        //find the shortest string's index
        //to prevent performance degradation
        int _min_len_ = strs[0].size();
        int _min_len_index_ = 0;        
        for (int i = 0; i &lt; strs.size(); ++i)
        {
            if (strs[i].size() &lt; _min_len_)
            {
                _min_len_ = strs[i].size();
                _min_len_index_ = i;
            }
        }


        string prefix = strs[_min_len_index_];
        for (int i = 0; i &lt; strs.size(); ++i)
        {
            if (strs[i].find(prefix) != 0)
            {
                prefix = prefix.substr(0, prefix.size() - 1);
                --i;
            }
        }
        return prefix;

    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Nth Node From End of List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/22/remove-nth-node-from-end-of-list/"/>
    <updated>2014-08-22T18:03:53+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/22/remove-nth-node-from-end-of-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a linked list, remove the nth node from the end of list and return its head.</p>

<p>For example,</p></blockquote>

<pre><code> Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.
 After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.
</code></pre>

<blockquote><p>Note:</p>

<p>Given n will always be valid.</p>

<p>Try to do this in one pass.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/remove-nth-node-from-end-of-list/">leetcode express</a></p>

<p><em>思路</em></p>

<ul>
<li>利用快慢指针，慢指针比快指针慢<code>n-1</code>步.</li>
<li>快指针指向最后一个结点时，慢指针指向倒数第<code>n+1</code>个结点（不能直接找倒数第n个结点，不方便删除）</li>
<li>为链表加一个多余的头结点，用来处理链表只有一个结点，并且要删除这个结点。</li>
</ul>


<pre><code class="c++ 时间复杂度 O(n)，空间复杂度 O(1)">
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *removeNthFromEnd(ListNode *head, int n) {

        ListNode *dummy = new ListNode(-1);
        dummy-&gt;next = head;
        ListNode *slow = dummy;
        ListNode *fast = dummy;

        while(n &gt; 0)
        {
            fast = fast-&gt;next;
            n--;
        }

        while(fast-&gt;next)
        {
            fast = fast-&gt;next;
            slow = slow-&gt;next;
        }

        ListNode *tmp = slow-&gt;next;
        slow-&gt;next = tmp-&gt;next;
        delete(tmp);
        tmp = dummy-&gt;next;
        delete(dummy);

        return tmp;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sort list]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/20/sort-list/"/>
    <updated>2014-08-20T19:07:30+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/20/sort-list</id>
    <content type="html"><![CDATA[<blockquote><p>Sort a linked list in O(n log n) time using constant space complexity.</p></blockquote>

<p><em>解法一</em></p>

<p>用递归方法将链表分组，再将每一层的分组两两合并。</p>

<pre><code class="c++ 时间复杂度 O(n log n) , 空间复杂度 O(1)">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:

    ListNode* mergeList(ListNode *fir, ListNode *sec)
    {
        if(!fir) return sec;
        if(!sec) return fir;
       ListNode *dummy = new ListNode(-1);
       ListNode *p = dummy;

       while(fir &amp;&amp; sec)
       {
           if(fir-&gt;val &lt; sec-&gt;val)
           {
               p-&gt;next = fir;
               fir = fir-&gt;next;
           }
           else 
           {
               p-&gt;next = sec;
               sec = sec-&gt;next;
           }
           p = p-&gt;next;
       }

       if(!fir) 
            p-&gt;next = sec;
       else
            p-&gt;next = fir;

        p=dummy-&gt;next;
        delete(dummy);
        return p;
    }

    ListNode *sortList(ListNode *head) {
        if(!head || !head-&gt;next) return head;
        ListNode *slow = head, *fast = head;

        // 防止指针越界
        while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)
        {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        fast = slow;
        slow = slow-&gt;next;
        fast-&gt;next = NULL;

        fast = sortList(head);
        slow = sortList(slow);

        return mergeList(fast,slow);
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Palindromic Substring]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/20/longest-palindromic-substring/"/>
    <updated>2014-08-20T15:21:20+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/20/longest-palindromic-substring</id>
    <content type="html"><![CDATA[<blockquote><p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/longest-palindromic-substring/">leetcode express</a></p>

<h3>本文参考 cnblog博主<a href="www.cnblogs.com/TenosDoIt/p/3675788.html">tenos 博客</a></h3>

<p><em>解法一</em></p>

<pre><code class="c++ Longest Palindromic Substring 时间复杂度O（n^2）,空间O（n^2）">
class Solution {
public:
    string longestPalindrome(string s) {
         const int len = s.size();
        if(len &lt;= 1)return s;
        bool dp[len][len];//dp[i][j]表示s[i..j]是否是回文,如果用vector来表示这个数组会超时
        memset(dp, 0, sizeof(dp));
        int resLeft = 0, resRight = 0;
        dp[0][0] = true;
        for(int i = 1; i &lt; len; i++)
        {
            dp[i][i] = true;
            dp[i][i-1] = true;//这个初始化容易忽略，当k=2时要用到
        }
        for(int k = 2; k &lt;= len; k++)//枚举子串长度
            for(int i = 0; i &lt;= len-k; i++)//枚举子串起始位置
            {
                if(s[i] == s[i+k-1] &amp;&amp; dp[i+1][i+k-2])
                {
                    dp[i][i+k-1] = true;
                    if(resRight-resLeft+1 &lt; k)
                    {
                        resLeft = i;
                        resRight = i+k-1;
                    }
                }
            }
        return s.substr(resLeft, resRight-resLeft+1);
    }
};
</code></pre>

<p><em>解法二</em></p>

<p>以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。时间复杂度O(n<sup>2</sup>)，空间O（1）</p>

<pre><code class="c++ Longest Palindromic Substring 时间复杂度O(n^2)，空间O（1）">class Solution {
public:
    string longestPalindrome(string s) {
         const int len = s.size();
        if(len &lt;= 1)return s;

        int start = 0, maxLen = 0;
        for(int i=1; i&lt; len; ++i)
        {
            //寻找以i-1,i为中心的偶数长度的回文
            int low = i-1, high = i;
            while(low &gt;=0 &amp;&amp; high &lt; len &amp;&amp; s[low] == s[high])
            {
                low--;
                high++;
            }
            if(high - low - 1 &gt; maxLen)
            {
                start = low+1;
                maxLen = high - low -1;
            }

            //寻找以i为中心的奇数长度的回文
            low = i-1; high = i+1;
            while(low &gt;=0 &amp;&amp; high &lt; len &amp;&amp; s[low] == s[high])
            {
                low--;
                high++;
            }

            if(high - low -1 &gt; maxLen)
            {
                maxLen = high - low - 1;
                start = low + 1;
            }
        }
        return s.substr(start, maxLen);
    }
};
</code></pre>

<p><em>解法3 Manacher算法</em></p>

<blockquote><p>该算法首先对字符串进行预处理，在字符串的每个字符前后都加入一个特殊符号，比如字符串abcd处理成 #a#b#c#d# ，为了避免处理越界，在字符串首位加上两个不同的特殊字符（此类型的字符串尾部不用加，自带‘\0’），这样预处理后最终便车工$#a#b#c#d#^,经过这样处理，原来的偶数长度的回文和奇数长度的回文在处理后的字符串都是奇数长度，假设处理后的字符串为s，对于已经预处理的字符串我们用数字p[i]来记录以字符s[i]为中心的最长回文字串向右或向左扩展的长度（包括s[i]），以字符串“12212321”为例，p数组如下：</p></blockquote>

<pre><code>s: $ # 1 # 2 # 2 # 1 # 2 # 3 # 2 # 1 # ^
p:   1 2 1 2 5 2 1 4 1 2 1 6 1 2 1 2 1
</code></pre>

<p>可以看出，P[i]-1正好是原字符串中回文串的总长度, 如果p数组已知，遍历p数组找到最大的p[i]就可以求出最长回文的长度，也可以求出回文的位置</p>

<p>下面给出求p[]数组的方法：</p>

<p>设id是当前求得的最长回文子串中心的位置，mx为当前最长回文子串的右边界（回文子串不包括该右边界），即mx = id + p[id]。记j = 2*id – i ，即 j 是 i 关于 id 的对称点。</p>

<ol>
<li>当i &lt; mx 时，如下图。此时可以得出一个非常神奇的结论p[i] >= min(p[2*id - i], mx - i)，下面我们来解释这个结论</li>
</ol>


<p><img src="http://images.cnitblog.com/blog/517264/201404/192355300257453.png" alt="" /></p>

<p>如何根据p[j]来求p[i]?要分两种情况：</p>

<ul>
<li>当mx-i>p[j]，这时候以s[j]为中心的回文字串包含在以s[id]为中心的回字串中，由于i和j对称，以s[i]为中心的回文字串必然包含在以s[id]为中心的回文字串中，所以p[i]至少等于p[j]，如下图：</li>
</ul>


<p>  <strong>注：这里其实p[i]一定等于p[j],后面不用再匹配了。因为如果p[i]后面还可以继续匹配，根据对称性，p[j]也可以继续扩展了</strong></p>

<p> <img src="http://images.cnitblog.com/blog/517264/201404/192355308851026.png" alt="" /></p>

<ul>
<li>当i >= mx, 无法对p[i]做更多的假设，只能p[i] = 1,然后再去匹配</li>
</ul>


<p> 算法复杂度分析：根据斜体字部分的注释，只有当mx-i = p[j]时 以及 i > mx时才要扩展比较，而mx也是在不断扩展的，总体而言每个元素比较次数是n的线性关系，所以时间复杂度为O(n)</p>

<pre><code class="c++ Manacher算法，时间复杂度O(n), 空间复杂度O(n)">class Solution {
public:
    string longestPalindrome(string s) {
        const int len = s.size();
        if(len &lt;= 1)return s;
        //Manncher算法 ，o（n）
        string str = preProcess(s);
        int n = str.size(), id = 0, mx = 0;
        vector&lt;int&gt;p(n, 0);
        for(int i = 1; i &lt; n-1; i++)
        {
            p[i] = mx &gt; i ? min(p[2*id-i], mx-i) : 1;
            //if(mx &lt;= i || (mx &gt; i &amp;&amp; p[2*id-i] == mx - i)) //根据正文斜体部分的注释，这里可要可不要
            while(str[i+p[i]] == str[i-p[i]])p[i]++;
            if(i + p[i] &gt; mx)
            {
                mx = i + p[i];
                id = i;
            }
        }

        //遍历p，寻找最大回文长度
        int maxLen = 0, index = 0;
        for(int i = 1; i &lt; n-1; i++)
            if(p[i] &gt; maxLen)
            {
                maxLen = p[i];
                index = i;
            }
        return s.substr((index - maxLen)/2, maxLen-1);
    }
    //预处理字符串，abc预处理后变成$#a#b#c#^
    string preProcess(const string &amp;s)
    {
        int n = s.size();
        string res;
        res.push_back('$');//把$放到字符串头部
        res.push_back('#');//以#作为原来字符串中每个字符的间隔
        for(int i = 0; i &lt; n; i++)
        {
            res.push_back(s[i]);
            res.push_back('#');
        }
        res.push_back('^');//以^作为字符串的结尾
        return res;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Copy List with Random Pointer]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/19/copy-list-with-random-pointer/"/>
    <updated>2014-08-19T22:52:45+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/19/copy-list-with-random-pointer</id>
    <content type="html"><![CDATA[<blockquote><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>

<p>Return a deep copy of the list.</p></blockquote>

<!--more-->


<p><a href="http://www.cnblogs.com/TenosDoIt/p/3387000.html">参考JustDoIT的cnblog</a></p>

<hr />

<pre><code class="c++ 复杂链表的复制">
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        if (!head) return NULL;

        map&lt;RandomListNode *, RandomListNode *&gt; oldListMap;

        RandomListNode *cur = head;
        RandomListNode *copyHead = new RandomListNode(-1);
        RandomListNode *curCopy = copyHead;


        while(cur)
        {
            oldListMap.insert(map&lt;RandomListNode *, RandomListNode *&gt;::value_type(cur,cur-&gt;next));
            RandomListNode *node = new RandomListNode(cur-&gt;label);
            node-&gt;random = cur;
            RandomListNode *p = cur;
            cur=cur-&gt;next;
            p-&gt;next = node;
            curCopy-&gt;next = node;
            curCopy=node;
        }

        curCopy = copyHead-&gt;next;
        while(curCopy)
        {
            if(curCopy-&gt;random-&gt;random)
                 curCopy-&gt;random = curCopy-&gt;random-&gt;random-&gt;next;
            else 
                curCopy-&gt;random = NULL;
            curCopy=curCopy-&gt;next;
        }

        cur = head;
        for(int i = 1; i&lt;= oldListMap.size(); i++)
        {
            cur-&gt;next = oldListMap[cur];
            cur=cur-&gt;next;
        }
        return copyHead-&gt;next;
    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
