<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-09-20T09:46:06+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rotate List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/14/rotate-list/"/>
    <updated>2014-09-14T16:08:37+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/14/rotate-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a list, rotate the list to the right by k places, where k is non-negative.<br/>
For example:
Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> and <code>k = 2</code>,<br/>
return <code>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code>.</p></blockquote>

<!--more-->


<p><strong>思路</strong><br/>
有点感冒，头晕晕乎乎的，还出冷汗，一开始脑子不够用，竟然套用翻转string的那个算法，还reverse三次，弱爆了。其次就是<code>k</code>的值可能大于链表长度，我没有去算链表长度，直接用快慢指针做的，这样对于特殊输入运行效率可能极其低下，回头修改，写完这点，回宿舍休息会去。</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *rotateRight(ListNode *head, int k) {
        if(!head || !head-&gt;next || k &lt; 1) return head;
        ListNode *p = head;
        for (int i=0; i&lt;k; i++) 
        {
            if (p-&gt;next == NULL) 
            {
                p = head;
            }
            else 
            {
                p = p-&gt;next;
            }
        }

        ListNode *q = head;
        while (p-&gt;next)
        {
            p = p-&gt;next;
            q = q-&gt;next;
        }
        p-&gt;next = head;

        ListNode *newHead = q-&gt;next;
        q-&gt;next = NULL;

        return newHead;
        }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Triangle]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/12/triangle/"/>
    <updated>2014-09-12T17:40:54+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/12/triangle</id>
    <content type="html"><![CDATA[<blockquote><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>

<p>For example, given the following triangle</p>

<pre><code>    [
         [2],       
        [3,4],  
       [6,5,7],  
      [4,1,8,3]  
    ]   
</code></pre>

<p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>

<p>Note:<br/>
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p></blockquote>

<!--more-->


<pre><code class="c++ ">
class Solution {
public:
    int minimumTotal(vector&lt;vector&lt;int&gt; &gt; &amp;triangle) {
        int n = triangle.size();
        vector&lt;int&gt; minNums = triangle[n-1];

        for (int i = n - 2; i &gt;= 0; i--)
        {
            for(int j = 0; j &lt;= i; j++)
            {
                minNums[j] = min(minNums[j], minNums[j+1]) + triangle[i][j];
            }
        }

        return minNums[0];
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trapping Rain Water]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/12/trapping-rain-water/"/>
    <updated>2014-09-12T15:40:57+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/12/trapping-rain-water</id>
    <content type="html"><![CDATA[<blockquote><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>

<p>For example, <br/>
Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.</p>

<p><img src="http://www.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt="" /><br/>
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p></blockquote>

<!--more-->


<pre><code class="c++ 时间复杂度O(n), 空间复杂度O(1)">class Solution {
public:
    int trap(int A[], int n) {
        int value = 0;
        int leftMax = 0;
        int rightMax = 0;
        int l = 0, r = n-1;
        while(l &lt;= r)
        {
            leftMax = max(leftMax, A[l]);
            rightMax = max(rightMax, A[r]);

            if(leftMax &lt; rightMax)
            {
                value += leftMax - A[l];
                l++;
            }
            else
            {
                value += rightMax - A[r];
                r--;
            }
        }

        return value;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Permutation Sequence]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/11/permutation-sequence/"/>
    <updated>2014-09-11T23:48:20+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/11/permutation-sequence</id>
    <content type="html"><![CDATA[<blockquote><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>

<p>By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):</p>

<ol>
<li>&ldquo;123&rdquo;</li>
<li>&ldquo;132&rdquo;</li>
<li>&ldquo;213&rdquo;</li>
<li>&ldquo;231&rdquo;</li>
<li>&ldquo;312&rdquo;</li>
<li>&ldquo;321&rdquo;</li>
</ol>


<p>Given n and k, return the k-th permutation sequence.</p>

<p>Note: Given n will be between 1 and 9 inclusive.</p></blockquote>

<!--more-->


<pre><code class="c++ 时间复杂度O(n),空间复杂度O(1)">class Solution {
public:
    int factorial(int n)
    {
        int res = 1;
        for(int i=2 ;i&lt;=n; i++)
            res *= i;
        return res;
    }
    string getPermutation(int n, int k) {
        int total = factorial(n);
          string candidate = string("123456789").substr(0, n);
          string res(n,' ');
          for(int i = 0; i &lt; n; i++)//依次计算排列的每个位
          {
              total /= (n-i);
             int index = (k-1) / total;
             res[i] = candidate[index];
             candidate.erase(index, 1);
             k -= index*total;
         }
         return res;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Search a 2D Matrix]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/04/search-a-2d-matrix/"/>
    <updated>2014-09-04T10:50:42+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/04/search-a-2d-matrix</id>
    <content type="html"><![CDATA[<blockquote><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>

<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>


<p>For example,</p>

<p>Consider the following matrix:</p></blockquote>

<pre><code>[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
</code></pre>

<blockquote><p>Given target = <code>3</code>, return <code>true</code>.</p></blockquote>

<!-- more-->


<p><a href="https://oj.leetcode.com/problems/search-a-2d-matrix/">leetcode express</a></p>

<p><strong>方法一</strong><br/>
先查找target可能在的行，再从行中找target</p>

<pre><code class="c++ 二分 时间复杂度 O(logm+logn)">class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt; &gt; &amp;matrix, int target) {
        int row = matrix.size() - 1;
        int col = matrix[0].size() - 1;

        //注意low从1开始
        int low = 1, high = row;
        while(low &lt;= high)
        {
            int mid = low + (high - low)/2;
           if (matrix[mid - 1][col] == target)
                return true;
            else if (matrix[mid -1][col] &gt; target)
                high = mid - 1;
            else
                low = mid + 1;
        }
        row = high;
        low = 0; high = col;
        while(low &lt;= high)
        {
            int mid = (low+high)/2;
            if(matrix[row][mid] == target)
                return true;
            else if(matrix[row][mid] &gt; target)
                high = mid -1;
            else 
                low = mid + 1;
        }
        return false;
    }
};
</code></pre>

<p><strong>方法二</strong></p>

<p>这个方法还没有第一个方法好。</p>

<p>&#8220;`c++ 时间复杂度O(n*logm)
class Solution {
public:
    bool searchMatrix(vector&lt;vector<int> > &amp;matrix, int target) {
        int row = matrix.size() - 1;
        int col = matrix[0].size() - 1;</p>

<pre><code>    for(int i = 0 ; i &lt;= row;)
    {
        int tmp = matrix[i][col];
        if(matrix[i][col] == target)
            return true;
        if(matrix[i][col] &gt; target)
        {
            int l = 0, r = col;
            while(l &lt;= r)
            {
                int mid = (l+r)/2;
                if(matrix[i][mid] == target)
                    return true;
                if(matrix[i][mid] &gt; target)
                    r = mid - 1;
                else
                    l = l + 1;
            }
            return false;
        } else
        {
            i++;
        }
    }

    return false;
}
</code></pre>

<p>};
&#8220;`</p>
]]></content>
  </entry>
  
</feed>
