<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: leetcode | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/leetcode/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-08-28T20:17:57+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pow(x,y)]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/27/pow-x/"/>
    <updated>2014-08-27T23:25:37+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/27/pow-x</id>
    <content type="html"><![CDATA[<blockquote><p>Implement pow(x, n).</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/powx-n/">leetcode express</a></p>

<pre><code class="c++">class Solution {
public:
    double pow(double x, int n) {
        if(n == 0) return 1;
        if(n &lt; 0) return 1 /( x * pow( x , -n-1));
        double num1 = x, num2 = 1;
        while(n &gt; 1)
        {
            if(n &amp; 0x1) num2 *= num1;
            num1 *= num1;
            n &gt;&gt;= 2;
        }
       return num1 * num2;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[next_permutation]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/26/next-permutation/"/>
    <updated>2014-08-26T13:51:45+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/26/next-permutation</id>
    <content type="html"><![CDATA[<blockquote><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.<br/>
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).<br/>
The replacement must be in-place, do not allocate extra memory.<br/>
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p></blockquote>

<pre><code> 1,2,3 → 1,3,2 
 3,2,1 → 1,2,3 
 1,1,5 → 1,5,1
</code></pre>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/next-permutation/">leetcode express</a></p>

<p><em>思路</em></p>

<ol>
<li>从后向前扫描 <code>vector&lt;int&gt; num</code>，寻找后一个数大于前一个数的位置，标记前一个数的index 为 <code>i</code>。</li>
<li>再从后面开始扫描，寻找第一个大于下标为<code>num[i]</code>的数（必然存在，主意一定是大于没有等于符号），标记符合条件的下标为<code>j</code>,交换<code>num[i]</code> ,<code>num[j]</code>。</li>
<li>将<code>index[i]</code>后的全部数字逆置，得到结果。</li>
</ol>


<p><strong>exception</strong></p>

<ul>
<li>若当前数字排序已经是能表示的最大数字，所以符合条件的下一个字典序为所有排列中最小的数字</li>
</ul>


<pre><code class="c++">class Solution {
public:
    void nextPermutation(vector&lt;int&gt; &amp;num) {
        int n = num.size();
        if(n &lt; 2) return;

        for(int i = n-2, ii = n-1; i &gt;= 0; i--, ii--)
        {
            if(num[i] &lt; num[ii])
            {
                int j = n-1;
                while(num[j] &lt;= num[i]) 
                    j--;
                swap(num[i],num[j]);
                reverse(num.begin()+ii,num.end());
                return;
            }
        }

        reverse(num.begin(), num.end());
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique Binary Search Trees]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/25/unique-binary-search-trees/"/>
    <updated>2014-08-25T20:17:26+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/25/unique-binary-search-trees</id>
    <content type="html"><![CDATA[<blockquote><p>Given n, how many structurally unique BST&rsquo;s (binary search trees) that store values 1&hellip;n?</p>

<p>For example,</p>

<p>Given n = 3, there are a total of 5 unique BST&rsquo;s.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/unique-binary-search-trees/">leetcode express</a></p>

<p><em>思路</em><br/>
二叉搜索树分为左子树，根，右子树。而每一个左子树又可继续划分为以上结构。同理右子树也可以进行同样的划分。使用一个数组来记录n个节点的二叉搜索树有多少种。后面使用时直接查询即可。</p>

<p>依次把每个节点作为根节点，左边节点作为左子树，右边节点作为右子树，那么总的数目等于左子树数目*右子树数目。</p>

<pre><code class="c++ DP">class Solution {
public:
    int numTrees(int n) {
        int array[n+1];
        memset(array,0,sizeof(array));
        array[0] = 1;

        for(int i=1; i&lt;=n; i++)
            for(int j=0;j&lt;i;j++)
                array[i] += array[j]*array[i-1-j];

        return array[n];
    }
};
</code></pre>

<p>实际上只需计算前半部分作为根节点的树的数目，然后乘以2（奇数节点还要加上中间节点作为根的二叉搜索树的数目）</p>

<pre><code class="c++ 只计算前半段划分">class Solution {
public:
    int numTrees(int n) {
        int array[n+1];
        memset(array,0,sizeof(array));
        array[0] = 1;

        for(int i=1; i&lt;=n; i++)
        {
            int tmp = i&gt;&gt;1;
            for(int j=1;j&lt;=tmp;j++)
            {
                array[i] += array[j-1]*array[i-j];
            }
            array[i] &lt;&lt;= 1;
            if(i &amp; 0x1)
                array[i] += array[tmp] * array[tmp]; 
        }

        return array[n];
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[two sum]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/25/two-sum/"/>
    <updated>2014-08-25T11:08:14+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/25/two-sum</id>
    <content type="html"><![CDATA[<blockquote><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>

<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>

<p>You may assume that each input would have exactly one solution.</p>

<p>  Input: numbers={2, 7, 11, 15}, target=9</p>

<p>  Output: index1=1, index2=2</p></blockquote>

<!--more-->


<p><em>思路</em></p>

<ol>
<li>用map存储整个vector，用vector中每个元素的值做pair的key，元素的index作为pair值，插入到map中</li>
<li>遍历数组时，从图中查找target-num[i]，利用图来降低时间复杂度 O(logN);</li>
</ol>


<pre><code class="c++ 时间复杂度 O(n), 空间复杂度O(n) ">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {
        vector&lt;int&gt; ret;
        if(numbers.size() &lt; 2) return ret;
        int i = 0, j = 0;
        map&lt;int,int&gt; nums;
        for(int i=0; i&lt; numbers.size(); i++)
        {
            nums.insert(pair&lt;int,int&gt;(numbers[i],i+1));
        }
        for(; i &lt; numbers.size(); i++)
        {
            int tmp = target - numbers[i];
            map&lt;int,int&gt;::iterator it = nums.find(tmp);
            if(it != nums.end())
            {
                int index1 = i+1;
                int index2 = it-&gt;second;
                if(index1&lt; index2)
                {
                    ret.push_back(index1);
                    ret.push_back(index2);
                    return ret;
                } 
                else if (index1 &gt; index2)
                {
                    ret.push_back(index2);
                    ret.push_back(index1);
                    return ret;
                }
            }
        }

        return ret;

    }
};
</code></pre>

<p><em>另一种解法</em></p>

<pre><code class="c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt; &amp;numbers, int target) {
        int len = numbers.size();
        assert(len &gt;= 2);   
        vector&lt;int&gt; ret(2,0);
        map&lt;int, int&gt; mapping;
        vector&lt;long long&gt; mul(len,0);

        for(int i=0; i&lt;len; ++i)
        {
            mul[i] = (target - numbers[i]) * numbers[i];
            if(mapping[mul[i]] &gt;0)
            {
                // 排除 numbers[i] == target/2 的情况
                if(numbers[mapping[mul[i]] -1] + numbers[i] == target)
                {
                    ret[0] = mapping[mul[i]];
                    ret[1] = i+1;
                    return ret;
                }
            }
            else
            {
                mapping[mul[i]] = i+1;
            }
        }

    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Common Prefix]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/22/longest-common-prefix/"/>
    <updated>2014-08-22T20:26:21+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/22/longest-common-prefix</id>
    <content type="html"><![CDATA[<blockquote><p>Write a function to find the longest common prefix string amongst an array of strings.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/longest-common-prefix/">leetcode express</a></p>

<p><em>思路</em></p>

<ul>
<li>从vector中找到长度最短的string，作为prefix</li>
<li>依次比较每个字串，如果前缀不同，则将prefix的最后一个字符删去，继续比较</li>
</ul>


<pre><code class="c++ 时间复杂度 O(mn),空间复杂度O(1)">
class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt; &amp;strs) {
        if (strs.size() == 0)
            return "";

        //find the shortest string's index
        //to prevent performance degradation
        int _min_len_ = strs[0].size();
        int _min_len_index_ = 0;        
        for (int i = 0; i &lt; strs.size(); ++i)
        {
            if (strs[i].size() &lt; _min_len_)
            {
                _min_len_ = strs[i].size();
                _min_len_index_ = i;
            }
        }


        string prefix = strs[_min_len_index_];
        for (int i = 0; i &lt; strs.size(); ++i)
        {
            if (strs[i].find(prefix) != 0)
            {
                prefix = prefix.substr(0, prefix.size() - 1);
                --i;
            }
        }
        return prefix;

    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
