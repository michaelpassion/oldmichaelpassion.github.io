<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 链表 | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/lian-biao/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-08-21T12:03:32+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[sort list]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/20/sort-list/"/>
    <updated>2014-08-20T19:07:30+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/20/sort-list</id>
    <content type="html"><![CDATA[<blockquote><p>Sort a linked list in O(n log n) time using constant space complexity.</p></blockquote>

<p><em>解法一</em></p>

<p>用递归方法将链表分组，再将每一层的分组两两合并。</p>

<pre><code class="c++ 时间复杂度 O(n log n) , 空间复杂度 O(1)">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:

    ListNode* mergeList(ListNode *fir, ListNode *sec)
    {
        if(!fir) return sec;
        if(!sec) return fir;
       ListNode *dummy = new ListNode(-1);
       ListNode *p = dummy;

       while(fir &amp;&amp; sec)
       {
           if(fir-&gt;val &lt; sec-&gt;val)
           {
               p-&gt;next = fir;
               fir = fir-&gt;next;
           }
           else 
           {
               p-&gt;next = sec;
               sec = sec-&gt;next;
           }
           p = p-&gt;next;
       }

       if(!fir) 
            p-&gt;next = sec;
       else
            p-&gt;next = fir;

        p=dummy-&gt;next;
        delete(dummy);
        return p;
    }

    ListNode *sortList(ListNode *head) {
        if(!head || !head-&gt;next) return head;
        ListNode *slow = head, *fast = head;

        // 防止指针越界
        while(fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next)
        {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        fast = slow;
        slow = slow-&gt;next;
        fast-&gt;next = NULL;

        fast = sortList(head);
        slow = sortList(slow);

        return mergeList(fast,slow);
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Copy List with Random Pointer]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/19/copy-list-with-random-pointer/"/>
    <updated>2014-08-19T22:52:45+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/19/copy-list-with-random-pointer</id>
    <content type="html"><![CDATA[<blockquote><p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>

<p>Return a deep copy of the list.</p></blockquote>

<!--more-->


<p><a href="http://www.cnblogs.com/TenosDoIt/p/3387000.html">参考JustDoIT的cnblog</a></p>

<hr />

<pre><code class="c++ 复杂链表的复制">
/**
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode *next, *random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        if (!head) return NULL;

        map&lt;RandomListNode *, RandomListNode *&gt; oldListMap;

        RandomListNode *cur = head;
        RandomListNode *copyHead = new RandomListNode(-1);
        RandomListNode *curCopy = copyHead;


        while(cur)
        {
            oldListMap.insert(map&lt;RandomListNode *, RandomListNode *&gt;::value_type(cur,cur-&gt;next));
            RandomListNode *node = new RandomListNode(cur-&gt;label);
            node-&gt;random = cur;
            RandomListNode *p = cur;
            cur=cur-&gt;next;
            p-&gt;next = node;
            curCopy-&gt;next = node;
            curCopy=node;
        }

        curCopy = copyHead-&gt;next;
        while(curCopy)
        {
            if(curCopy-&gt;random-&gt;random)
                 curCopy-&gt;random = curCopy-&gt;random-&gt;random-&gt;next;
            else 
                curCopy-&gt;random = NULL;
            curCopy=curCopy-&gt;next;
        }

        cur = head;
        for(int i = 1; i&lt;= oldListMap.size(); i++)
        {
            cur-&gt;next = oldListMap[cur];
            cur=cur-&gt;next;
        }
        return copyHead-&gt;next;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reorder List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/17/reorder-list/"/>
    <updated>2014-08-17T16:32:11+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/17/reorder-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a singly linked list L: <code>L0→L1→…→Ln-1→Ln,</code></p>

<p>reorder it to: <code>L0→Ln→L1→Ln-1→L2→Ln-2→…</code></p>

<p>You must do this in-place without altering the nodes&#8217; values.</p>

<p>For example,
Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/reorder-list/">leetcode express</a></p>

<p><em>思路</em></p>

<p> 这题的难度在于问题的规模上，需要把一个字符串划分成两个字符串（快慢指针），将第二个字符串（后半个）逆置（原地逆置，头插法），再将两个字符串合并。代码如下.
 
&#8220;`c++ Reorder List</p>

<p>/<em><em>
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode </em>next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 </em>/
class Solution {
public:
    ListNode<em> findHalfNode(ListNode </em>head)
    {
        ListNode <em>fast = head;
        ListNode </em>slow = head;</p>

<pre><code>    while(fast &amp;&amp; fast-&gt;next)
    {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }
    return slow;
}

ListNode* reverseList(ListNode *head)
{
    ListNode *dummy = new ListNode(-1);
    dummy-&gt;next = head;

    ListNode *cur = head-&gt;next;
    head-&gt;next = NULL;
    while(cur)
    {
        ListNode *tmp = cur;
        cur =cur-&gt;next;
        tmp-&gt;next = dummy-&gt;next;
        dummy-&gt;next = tmp;
    }
    head = dummy-&gt;next;
    delete(dummy);
    return head;
}

void mergeTwoList(ListNode *first, ListNode *second)
{
    ListNode *pFir = first;
    ListNode *pSec = second;

    while(pSec)
    {
        ListNode *tmp = pSec;
        pSec = pSec-&gt;next;
        tmp-&gt;next = pFir-&gt;next;
        pFir-&gt;next = tmp;
        pFir = tmp-&gt;next;
    }
}
void reorderList(ListNode *head) {
    if(!head || !head-&gt;next || !head-&gt;next-&gt;next) return;
    ListNode *sec, *fir;

    sec = findHalfNode(head);
    fir = sec;
    sec = sec-&gt;next;
    fir-&gt;next = NULL;
    fir = head;
    sec = reverseList(sec);
    mergeTwoList(fir,sec);

}
</code></pre>

<p>};</p>

<p>&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates from Sorted List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/13/remove-duplicates-from-sorted-list/"/>
    <updated>2014-08-13T10:55:33+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/13/remove-duplicates-from-sorted-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>

<p>For example,</p>

<p>Given 1->1->2, return 1->2.</p>

<p>Given 1->1->2->3->3, return 1->2->3.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/">leetcode 传送门</a></p>

<p>这题比较简单，直接上代码</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        if(head==NULL || head-&gt;next == NULL ) return head;
        ListNode *p = head;
        ListNode *q =p-&gt;next;

        while(q)
        {
            if(p-&gt;val == q-&gt;val)
            {
                ListNode *tmp = q;
                q=q-&gt;next;
                delete(tmp);
                p-&gt;next = q;
            }
            else
            {
                p = q;
                q= q-&gt;next;
            }
        }
        return head;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insertion Sort List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/insertion-sort-list/"/>
    <updated>2014-08-10T19:35:54+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/insertion-sort-list</id>
    <content type="html"><![CDATA[<blockquote><p>Sort a linked list using insertion sort.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/insertion-sort-list/">leetcode 传送门</a></p>

<hr />

<p><em>思路</em>
过程比较清晰的链表操作题，一开始提交出现RE，看了下原来是</p>

<p><code>while(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val)</code> 写成了</p>

<p><code>while(p-&gt;next-&gt;val &lt; cur-&gt;val &amp;&amp; p-&gt;next)</code> 如果不先判断Node是否为空就去取值必然出现问题。</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {

        ListNode *p = head;
        if(p == NULL || p-&gt;next == NULL) return head;

        ListNode *dummy = new ListNode(-1);
        dummy-&gt;next = head;
        ListNode *cur = head-&gt;next;
        head-&gt;next = NULL;

        while(cur)
        {
            ListNode *p = dummy;
            while(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val)
            {
                p=p-&gt;next;
            }

            ListNode *tmp = cur;
            cur=cur-&gt;next;
            tmp-&gt;next = p-&gt;next;
            p-&gt;next = tmp;
        }
        return dummy-&gt;next;

    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
