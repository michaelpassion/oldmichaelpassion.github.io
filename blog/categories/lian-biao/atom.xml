<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 链表 | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/lian-biao/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-08-14T12:02:17+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates from Sorted List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/13/remove-duplicates-from-sorted-list/"/>
    <updated>2014-08-13T10:55:33+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/13/remove-duplicates-from-sorted-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>

<p>For example,</p>

<p>Given 1->1->2, return 1->2.</p>

<p>Given 1->1->2->3->3, return 1->2->3.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/">leetcode 传送门</a></p>

<p>这题比较简单，直接上代码</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        if(head==NULL || head-&gt;next == NULL ) return head;
        ListNode *p = head;
        ListNode *q =p-&gt;next;

        while(q)
        {
            if(p-&gt;val == q-&gt;val)
            {
                ListNode *tmp = q;
                q=q-&gt;next;
                delete(tmp);
                p-&gt;next = q;
            }
            else
            {
                p = q;
                q= q-&gt;next;
            }
        }
        return head;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insertion Sort List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/insertion-sort-list/"/>
    <updated>2014-08-10T19:35:54+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/insertion-sort-list</id>
    <content type="html"><![CDATA[<blockquote><p>Sort a linked list using insertion sort.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/insertion-sort-list/">leetcode 传送门</a></p>

<hr />

<p><em>思路</em>
过程比较清晰的链表操作题，一开始提交出现RE，看了下原来是</p>

<p><code>while(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val)</code> 写成了</p>

<p><code>while(p-&gt;next-&gt;val &lt; cur-&gt;val &amp;&amp; p-&gt;next)</code> 如果不先判断Node是否为空就去取值必然出现问题。</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {

        ListNode *p = head;
        if(p == NULL || p-&gt;next == NULL) return head;

        ListNode *dummy = new ListNode(-1);
        dummy-&gt;next = head;
        ListNode *cur = head-&gt;next;
        head-&gt;next = NULL;

        while(cur)
        {
            ListNode *p = dummy;
            while(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val)
            {
                p=p-&gt;next;
            }

            ListNode *tmp = cur;
            cur=cur-&gt;next;
            tmp-&gt;next = p-&gt;next;
            p-&gt;next = tmp;
        }
        return dummy-&gt;next;

    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
