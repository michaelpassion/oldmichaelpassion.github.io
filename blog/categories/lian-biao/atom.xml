<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 链表 | My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/blog/categories/lian-biao/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-08-17T16:38:42+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Reorder List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/17/reorder-list/"/>
    <updated>2014-08-17T16:32:11+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/17/reorder-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a singly linked list L: <code>L0→L1→…→Ln-1→Ln,</code></p>

<p>reorder it to: <code>L0→Ln→L1→Ln-1→L2→Ln-2→…</code></p>

<p>You must do this in-place without altering the nodes&#8217; values.</p>

<p>For example,
Given <code>{1,2,3,4}</code>, reorder it to <code>{1,4,2,3}</code>.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/reorder-list/">leetcode express</a></p>

<p><em>思路</em></p>

<p> 这题的难度在于问题的规模上，需要把一个字符串划分成两个字符串（快慢指针），将第二个字符串（后半个）逆置（原地逆置，头插法），再将两个字符串合并。代码如下.
 
&#8220;`c++ Reorder List</p>

<p>/<em><em>
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode </em>next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 </em>/
class Solution {
public:
    ListNode<em> findHalfNode(ListNode </em>head)
    {
        ListNode <em>fast = head;
        ListNode </em>slow = head;</p>

<pre><code>    while(fast &amp;&amp; fast-&gt;next)
    {
        fast = fast-&gt;next-&gt;next;
        slow = slow-&gt;next;
    }
    return slow;
}

ListNode* reverseList(ListNode *head)
{
    ListNode *dummy = new ListNode(-1);
    dummy-&gt;next = head;

    ListNode *cur = head-&gt;next;
    head-&gt;next = NULL;
    while(cur)
    {
        ListNode *tmp = cur;
        cur =cur-&gt;next;
        tmp-&gt;next = dummy-&gt;next;
        dummy-&gt;next = tmp;
    }
    head = dummy-&gt;next;
    delete(dummy);
    return head;
}

void mergeTwoList(ListNode *first, ListNode *second)
{
    ListNode *pFir = first;
    ListNode *pSec = second;

    while(pSec)
    {
        ListNode *tmp = pSec;
        pSec = pSec-&gt;next;
        tmp-&gt;next = pFir-&gt;next;
        pFir-&gt;next = tmp;
        pFir = tmp-&gt;next;
    }
}
void reorderList(ListNode *head) {
    if(!head || !head-&gt;next || !head-&gt;next-&gt;next) return;
    ListNode *sec, *fir;

    sec = findHalfNode(head);
    fir = sec;
    sec = sec-&gt;next;
    fir-&gt;next = NULL;
    fir = head;
    sec = reverseList(sec);
    mergeTwoList(fir,sec);

}
</code></pre>

<p>};</p>

<p>&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates from Sorted List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/13/remove-duplicates-from-sorted-list/"/>
    <updated>2014-08-13T10:55:33+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/13/remove-duplicates-from-sorted-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>

<p>For example,</p>

<p>Given 1->1->2, return 1->2.</p>

<p>Given 1->1->2->3->3, return 1->2->3.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/remove-duplicates-from-sorted-list/">leetcode 传送门</a></p>

<p>这题比较简单，直接上代码</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        if(head==NULL || head-&gt;next == NULL ) return head;
        ListNode *p = head;
        ListNode *q =p-&gt;next;

        while(q)
        {
            if(p-&gt;val == q-&gt;val)
            {
                ListNode *tmp = q;
                q=q-&gt;next;
                delete(tmp);
                p-&gt;next = q;
            }
            else
            {
                p = q;
                q= q-&gt;next;
            }
        }
        return head;
    }
};
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insertion Sort List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/10/insertion-sort-list/"/>
    <updated>2014-08-10T19:35:54+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/10/insertion-sort-list</id>
    <content type="html"><![CDATA[<blockquote><p>Sort a linked list using insertion sort.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/insertion-sort-list/">leetcode 传送门</a></p>

<hr />

<p><em>思路</em>
过程比较清晰的链表操作题，一开始提交出现RE，看了下原来是</p>

<p><code>while(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val)</code> 写成了</p>

<p><code>while(p-&gt;next-&gt;val &lt; cur-&gt;val &amp;&amp; p-&gt;next)</code> 如果不先判断Node是否为空就去取值必然出现问题。</p>

<pre><code class="c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {

        ListNode *p = head;
        if(p == NULL || p-&gt;next == NULL) return head;

        ListNode *dummy = new ListNode(-1);
        dummy-&gt;next = head;
        ListNode *cur = head-&gt;next;
        head-&gt;next = NULL;

        while(cur)
        {
            ListNode *p = dummy;
            while(p-&gt;next &amp;&amp; p-&gt;next-&gt;val &lt; cur-&gt;val)
            {
                p=p-&gt;next;
            }

            ListNode *tmp = cur;
            cur=cur-&gt;next;
            tmp-&gt;next = p-&gt;next;
            p-&gt;next = tmp;
        }
        return dummy-&gt;next;

    }
};
</code></pre>
]]></content>
  </entry>
  
</feed>
