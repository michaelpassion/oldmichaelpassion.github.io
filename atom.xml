<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-11-19T19:56:16+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ZigZag Conversion]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/19/zigzag-conversion/"/>
    <updated>2014-11-19T19:51:18+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/19/zigzag-conversion</id>
    <content type="html"><![CDATA[<blockquote><p>The string <code>"PAYPALISHIRING"</code> is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</p>

<p>P   A   H   N<br/>
A P L S I I G<br/>
Y   I   R<br/>
And then read line by line: &ldquo;PAHNAPLSIIGYIR&rdquo;
Write the code that will take a string and make this conversion given a number of rows:</p>

<p>string convert(string text, int nRows);
<code>convert("PAYPALISHIRING", 3)</code> should return<code>"PAHNAPLSIIGYIR"</code>.</p></blockquote>

<!--more-->


<p><strong>解题思路</strong>
找了好长时间规律，有点乱，没有分析出合适的公式，看到这个方法，很直观，很赞，用到一个<code>step</code>变量去控制向哪一个<code>string</code>添加。而且有相当好的时间复杂度。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Solution {
</span><span class='line'>public:
</span><span class='line'>    string convert(string s, int nRows) {
</span><span class='line'>        if (nRows &lt; 2) return s;
</span><span class='line'>        const int len = s.length();
</span><span class='line'>        string res[nRows];
</span><span class='line'>        int step = 1, row = 0;
</span><span class='line'>        for (int i =0; i&lt; len; i++)
</span><span class='line'>        {
</span><span class='line'>           res[row] += s[i];
</span><span class='line'>           if (row == 0)
</span><span class='line'>           {
</span><span class='line'>               step = 1;
</span><span class='line'>               
</span><span class='line'>           }else if (row == nRows-1)
</span><span class='line'>               step = -1;
</span><span class='line'>            row += step;
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        for(int i=1; i&lt; nRows; i++)
</span><span class='line'>            res[0]+=res[i];
</span><span class='line'>        return res[0];
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Valid Sudoku]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/19/valid-sudoku/"/>
    <updated>2014-11-19T17:38:58+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/19/valid-sudoku</id>
    <content type="html"><![CDATA[<blockquote><p>Determine if a Sudoku is valid, according to: <a href="http://sudoku.com.au/TheRules.aspx">Sudoku Puzzles - The Rules</a>.</p>

<p>The Sudoku board could be partially filled, where empty cells are filled with the character <code>'.'</code>.<br/>
<img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="" /></p>

<p>A partially filled sudoku which is valid.<br/>
Note:A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p></blockquote>

<!--more-->


<p><strong>解题思路</strong><br/>
这道题要求检查数独是否有效，既检查数独里的每一行，每一列，每一个九宫格里有没有重复数字，若有，则数独是无效的。通过一个双层循环可以实现以上三种检查，难点在检查九宫格。<br/>
以下方法定义了三个数组，分别用来检查行，列，九宫格，相当于三个hash table。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Solution {
</span><span class='line'>public:
</span><span class='line'>    bool isValidSudoku(vector&lt;vector&lt;char&gt; &gt; &board) {
</span><span class='line'>        int checkRow[10] = {0};
</span><span class='line'>        int checkCol[10] = {0};
</span><span class='line'>        int checkSqu[10] = {0};
</span><span class='line'>        for(int i=0; i&lt; 9; ++i)
</span><span class='line'>        {
</span><span class='line'>            memset(checkRow,0,sizeof(checkRow));
</span><span class='line'>            memset(checkCol,0,sizeof(checkCol));
</span><span class='line'>            memset(checkSqu,0,sizeof(checkSqu));
</span><span class='line'>            for(int j=0; j&lt; 9; ++j)
</span><span class='line'>            {
</span><span class='line'>               if(!checkValid(checkRow,board[i][j]-'0') || 
</span><span class='line'>                  !checkValid(checkCol,board[j][i]-'0') ||
</span><span class='line'>                  !checkValid (checkSqu,board[3*(i/3)+j/3][3*(i%3)+j%3]-'0'))
</span><span class='line'>                  return false;
</span><span class='line'>                
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return true;
</span><span class='line'>    }
</span><span class='line'>    bool checkValid(int a[], int val)
</span><span class='line'>    {
</span><span class='line'>        if (val &lt; 0) return true;
</span><span class='line'>        if (a[val] == 1) return false;
</span><span class='line'>        a[val] = 1;
</span><span class='line'>        return true;
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add Binary]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/19/add-binary/"/>
    <updated>2014-11-19T13:11:32+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/19/add-binary</id>
    <content type="html"><![CDATA[<blockquote><p>Given two binary strings, return their sum (also a binary string).</p>

<p>For example,<br/>
a = <code>"11"</code><br/>
b = <code>"1"</code><br/>
Return <code>"100"</code>.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/add-binary/">leetcode express</a></p>

<p><strong>解题思路</strong>
类似于多项式相加，用位运算加速计算，<code>carry</code>用来保存进位，<code>tmp</code>保存两个二进制数第<code>i</code>位的和，再和carry相加，并将结果加入<code>res</code>中，最后因为<code>res</code>是逆序的，再将<code>res</code>翻转一遍。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Solution {
</span><span class='line'>public:
</span><span class='line'>    string addBinary(string a, string b) {
</span><span class='line'>        int result=0, carry =0;
</span><span class='line'>        string res = "";
</span><span class='line'>        int aLen = a.length()-1;
</span><span class='line'>        int bLen = b.length()-1;
</span><span class='line'>        int tmp;
</span><span class='line'>        
</span><span class='line'>        while(aLen &gt;=0 && bLen &gt;=0)
</span><span class='line'>        {
</span><span class='line'>            result = (a[aLen]-'0')^(b[bLen] - '0');
</span><span class='line'>            tmp = (result ^ carry);
</span><span class='line'>            res +=to_string(tmp);
</span><span class='line'>            carry = (a[aLen--]- '0')+(b[bLen--] - '0')+carry &gt;= 2 ? 1 : 0;
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        while (aLen&gt;=0) {
</span><span class='line'>            tmp = ((a[aLen]-'0')^carry);
</span><span class='line'>            res += to_string(tmp);
</span><span class='line'>            carry = (a[aLen]-'0')&carry;
</span><span class='line'>            aLen--;
</span><span class='line'>        }
</span><span class='line'>        while (bLen&gt;=0) {
</span><span class='line'>            tmp = ((b[bLen]-'0')^carry);
</span><span class='line'>            res += to_string(tmp);
</span><span class='line'>            carry = (b[bLen]-'0')&carry;
</span><span class='line'>            bLen--;
</span><span class='line'>        }
</span><span class='line'>        if (carry == 1) {
</span><span class='line'>            res += to_string(carry);
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        int l =0, r= res.length()-1;
</span><span class='line'>        while(l &lt; r)
</span><span class='line'>        {
</span><span class='line'>            swap(res[l],res[r]);
</span><span class='line'>            l++;r--;
</span><span class='line'>        }
</span><span class='line'>    
</span><span class='line'>        return res;
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Count and Say]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/18/count-and-say/"/>
    <updated>2014-11-18T22:54:58+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/18/count-and-say</id>
    <content type="html"><![CDATA[<blockquote><p>The count-and-say sequence is the sequence of integers beginning as follows:
<code>1, 11, 21, 1211, 111221, ...</code></p>

<p><code>1</code> is read off as <code>"one 1"</code> or <code>11</code>.<br/>
<code>11</code> is read off as <code>"two 1s"</code> or<code>21</code>.<br/>
<code>21</code> is read off as <code>"one 2, then one 1"</code> or <code>1211</code>.<br/>
Given an integer <code>n</code>, generate the <code>nth</code> sequence.</p>

<p>Note: The sequence of integers will be represented as a string.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/count-and-say/">leetcode express</a></p>

<p><strong>解题思路</strong>
最开始想到递归，因为后一个字符串是通过前一个字符串确定的，但是转念一想只需要一个字符串来保存状态即可，以下解法公参考：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Solution {
</span><span class='line'>public:
</span><span class='line'>    string countAndSay(int n) {
</span><span class='line'>        if (n == 1)  return "1";
</span><span class='line'>        string a = "1";
</span><span class='line'>        string tmp = "";
</span><span class='line'>        for (int i=0; i&lt; n-1; i++) {
</span><span class='line'>            int count = 1;
</span><span class='line'>            
</span><span class='line'>            for (int j=0; j&lt;a.length(); j++) {
</span><span class='line'>                if(a[j] == a[j+1])
</span><span class='line'>                    count++;
</span><span class='line'>                else
</span><span class='line'>                {
</span><span class='line'>                    tmp += to_string(count) + a[j];
</span><span class='line'>                    count=1;
</span><span class='line'>    
</span><span class='line'>                }
</span><span class='line'>            }
</span><span class='line'>            a = tmp;
</span><span class='line'>            tmp = "";
</span><span class='line'>        }
</span><span class='line'>        
</span><span class='line'>        return a;
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Min Stack]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/14/min-stack/"/>
    <updated>2014-11-14T10:08:06+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/14/min-stack</id>
    <content type="html"><![CDATA[<blockquote><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p>

<p>push(x) &ndash; Push element x onto stack.<br/>
pop() &ndash; Removes the element on top of the stack.<br/>
top() &ndash; Get the top element.<br/>
getMin() &ndash; Retrieve the minimum element in the stack.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/min-stack/">Leetcode express</a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">MinStack</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
</span><span class='line'><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">min</span><span class="p">;</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">nums</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">min</span><span class="p">.</span><span class="n">top</span><span class="p">())</span>
</span><span class='line'>            <span class="n">min</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">void</span> <span class="n">pop</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">top</span><span class="p">()</span> <span class="o">==</span> <span class="n">min</span><span class="p">.</span><span class="n">top</span><span class="p">())</span>
</span><span class='line'>            <span class="n">min</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'>        <span class="n">nums</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">top</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">nums</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">getMin</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">min</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[test]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/06/test/"/>
    <updated>2014-11-06T23:17:48+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/06/test</id>
    <content type="html"><![CDATA[<p>Hello World !!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find Minimum in Rotated Sorted Array II]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/11/03/find-minimum-in-rotated-sorted-array-ii/"/>
    <updated>2014-11-03T23:22:11+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/11/03/find-minimum-in-rotated-sorted-array-ii</id>
    <content type="html"><![CDATA[<blockquote><p>Follow up for &ldquo;Find Minimum in Rotated Sorted Array&rdquo;:<br/>
What if duplicates are allowed?</p>

<p>Would this affect the run-time complexity? How and why?</p></blockquote>

<p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>

<p>Find the minimum element.</p>

<p>The array may contain duplicates.</p>

<!--more-->


<p></p>

<p><strong>思路</strong><br/>
由于是旋转数组，可以说基本有序，可以用二分的方法去筛去最小值肯定不存在的部分。</p>

<figure class='code'><figcaption><span>时间复杂度O(logn) </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">findMin</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">findHelper</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">findHelper</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">,</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span><span class="o">+</span> <span class="p">(</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 3,1,3,3 情况</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">end</span><span class="p">])</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">findHelper</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">findHelper</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">end</span><span class="p">);</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="o">?</span> <span class="nl">a</span> <span class="p">:</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="c1">// 1,3,3</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">end</span><span class="p">])</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">findHelper</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">end</span><span class="p">);</span>
</span><span class='line'>             <span class="c1">// </span>
</span><span class='line'>            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">end</span><span class="p">])</span>
</span><span class='line'>                 <span class="k">return</span> <span class="n">findHelper</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span>
</span><span class='line'>            <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span><span class="o">&lt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">end</span><span class="p">])</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">findHelper</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">mid</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">num</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>非递归方法</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">findMin</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span><span class="o">+</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">num</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="p">)</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="n">l</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>                    <span class="n">r</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">num</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
</span><span class='line'>                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">num</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>以上两个方法，都不是很优雅，对于特殊情况的判断是根据oj提供的错误信息，经过几次改正才得到的结果，不是很清晰，可能oj提供的case不足以证明这两个方法的正确性，若各位发现错误，或有好的建议，欢迎留言 XD 。</p>

<p><strong><em>Much better way</em></strong></p>

<p>&#8220;`c++
    class Solution {
public:
    int findMin(vector<int> &amp;num) {
        int len = num.size();
        if (len &lt; 2) return num[0];
        int l = 0, r = len-1;</p>

<pre><code>    while(l &lt; r &amp;&amp; num[l] &gt;= num[r])
    {
        int mid = (l + r)/2;
        if (num[mid] &gt; num[l])
            l = mid + 1;
        else if (num[mid] &lt; num[r])
            r = mid;
        else
            l = l+1;
    }
    return num[l];
}
</code></pre>

<p>};&#8220;`</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jin Qi Mian Shi Ti]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/10/24/jin-qi-mian-shi-ti/"/>
    <updated>2014-10-24T00:00:00+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/10/24/jin-qi-mian-shi-ti</id>
    <content type="html"><![CDATA[<p>还是那句话最近很忙，不过这两天还好了一点了，陆陆续续的各种笔试面试参加下来，没有斩获什么offer比较失败，百度跪在了二面，面试官说我开发经验不足，这倒是真的，我的项目经历，水到不行，而且由于真实没有太多时间去搞iOS开发，所以甚至一些基础知识的东西也不是很了解。另外也许是我在写算法题的时候过于表现的太过草率了。反正就是自己不够强，多说无益，继续努力吧。</p>

<!--more-->


<p>UIApplication 生命周期</p>

<hr />

<ul>
<li><code>- (BOOL)application:(UIApplication *)application   willFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code>  这个函数将会在你得App打开后主要的<strong>storyboard</strong>或是<strong>nib</strong>文件被加载后，在app状态被保存前(不甚理解)调用。当这个函数调用时，你的app处于休眠状态。 <br/>
 如果你的app是由系统出于特定原因启动的，<code>launchOptions</code>字典中的数据将指明启动的原因。出于某些原因，系统可能调用你的app的代理的附加方法。</li>
<li><code>- (BOOL)application:(UIApplication *)application
didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
</code></li>
<li><code>- (void)applicationDidBecomeActive:(UIApplication *)application</code></li>
<li><code>- (void)applicationWillResignActive:(UIApplication *)application</code> 调用这个方法让你的app知道，它要从运行态转入不活跃。当有短信或者电话打来时或者用户退出应用应用转入后台时。处于不活跃状态的app仍然在运行指示不在向responder发送数据</li>
<li><code>- (void)applicationDidEnterBackground:(UIApplication *)application</code></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find Minimum in Rotated Sorted Array]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/10/17/find-minimum-in-rotated-sorted-array/"/>
    <updated>2014-10-17T21:54:04+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/10/17/find-minimum-in-rotated-sorted-array</id>
    <content type="html"><![CDATA[<blockquote><p>Suppose a sorted array is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).</p>

<p>Find the minimum element.</p>

<p>You may assume no duplicate exists in the array.</p></blockquote>

<!--more-->


<p>leetcode 出新题了，看起来是个水题，一时技痒就写了（不害臊，打脸）(￣ε(#￣)☆╰╮(￣▽￣///)</p>

<p><strong>思路</strong><br/>
因为是旋转的有序数组，所以可以看成是两个分别有序的递增数组，又前一个数组中的值肯定大于后一个数组中的值，所以只需遍历前面数组，找到比指向后一个数组最后一个数字小的第一个数字就是整个旋转有序数组的最小值。<br/>
<em>特殊情况</em> ：如果原数组并没有旋转，那么<code>num[0] &lt; num[n-1]</code>, 直接返回<code>num[0]</code></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">findMin</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">num</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">num</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
</span><span class='line'>                <span class="n">l</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>            <span class="k">else</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">num</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">num</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Niu Zi Hen Mang]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/10/17/niu-zi-hen-mang/"/>
    <updated>2014-10-17T00:00:00+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/10/17/niu-zi-hen-mang</id>
    <content type="html"><![CDATA[<p>最近笔试太忙，面试太忙，好多东西来不及整理，难熬的求职季，等我拿到好的offer，定来好好整理，虽然博客没有多少读者（甚至没有）。希望有心人能够看到，避免踏入我走过的坑中，也给自己的青春一个总结。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[人人笔试]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/10/14/ren-ren-bi-shi/"/>
    <updated>2014-10-14T22:19:27+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/10/14/ren-ren-bi-shi</id>
    <content type="html"><![CDATA[<p>有难度的题不是很多，一个是进制转换，另一个是比较好的题是大题。 <br/>
1. 有一种生物，单性繁殖，从出生后第三个月起产生m个后代，第五个月后死亡，求n个月后生物的总量是多少？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[区分接口继承和实现继承]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/10/08/qu-fen-jie-kou-ji-cheng-he-shi-xian-ji-cheng/"/>
    <updated>2014-10-08T10:20:06+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/10/08/qu-fen-jie-kou-ji-cheng-he-shi-xian-ji-cheng</id>
    <content type="html"><![CDATA[<!--more-->


<p><strong>成员函数的结构总是会被继承</strong><br/>
public继承意味<strong>is-a</strong>,所以对base class为真的任何事情一定也对其derived classes为真。<br/>
<strong>声明一个pure virtual函数的目的是为了让 derived classes 只继承函数的接口</strong><br/>
<strong>声明impure virtual函数是为了让 derived classes 继承该函数的接口和缺省实现</strong><br/>
<strong> 声明non-virtual函数的目的是为了令 derived classes 继承函数的接口及一份强制性实现 </strong></p>

<h2>为多态基类声明 virtual 析构函数</h2>

<hr />

<p>c++明确指出： 当derived class 对象经由一个 base class 指针删除， 而该 base class 带着一个 non-virtual 析构函数，其结果未有定义 &ndash; 实际执行时通常发生的是对象的 derived 成分没有被销毁，然而base class 成分会被销毁，造成一个诡异的“局部销毁”的对象。<br/>
    消除这个问题的做法是：给 base class 一个virtual 析构函数。此后删除 derived classes 对象就会调用 derived classes的析构函数</p>

<h2>绝对不重新定义继承而来的缺省参数值</h2>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Balanced Binary Tree]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/10/07/balanced-binary-tree/"/>
    <updated>2014-10-07T21:54:20+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/10/07/balanced-binary-tree</id>
    <content type="html"><![CDATA[<blockquote><p>Given a binary tree, determine if it is height-balanced.</p>

<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p></blockquote>

<p><a href="https://oj.leetcode.com/problems/balanced-binary-tree/">leetcode express</a></p>

<p><strong>解析</strong> <br/>
<strong>算法一</strong> <br/>
分别去求左子树的最大深度和右子树的最大深度，若两个子树深度之差不大于1，即为平衡二叉树。</p>

<figure class='code'><figcaption><span>84ms 时间复杂度o(n^2)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Definition for binary tree</span>
</span><span class='line'><span class="cm"> * struct TreeNode {</span>
</span><span class='line'><span class="cm"> *     int val;</span>
</span><span class='line'><span class="cm"> *     TreeNode *left;</span>
</span><span class='line'><span class="cm"> *     TreeNode *right;</span>
</span><span class='line'><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span>
</span><span class='line'><span class="cm"> * };</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">isBalanced</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">left</span><span class="o">-</span><span class="n">right</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nf">isBalanced</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isBalanced</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">dfs</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span><span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>算法二</strong></p>

<figure class='code'><figcaption><span>56 ms 时间复杂度o(n)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Definition for binary tree</span>
</span><span class='line'><span class="cm"> * struct TreeNode {</span>
</span><span class='line'><span class="cm"> *     int val;</span>
</span><span class='line'><span class="cm"> *     TreeNode *left;</span>
</span><span class='line'><span class="cm"> *     TreeNode *right;</span>
</span><span class='line'><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span>
</span><span class='line'><span class="cm"> * };</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">checkBalance</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">//check left subtree is balanced</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">leftCheck</span> <span class="o">=</span> <span class="n">checkBalance</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">leftCheck</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">//check right subtree is balanced</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">rightCheck</span> <span class="o">=</span> <span class="n">checkBalance</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">rightCheck</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">//check current node is balanced</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">leftCheck</span> <span class="o">-</span> <span class="n">rightCheck</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max</span><span class="p">(</span><span class="n">leftCheck</span><span class="p">,</span> <span class="n">rightCheck</span><span class="p">);</span>
</span><span class='line'>        <span class="k">else</span>
</span><span class='line'>            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">isBalanced</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">checkBalance</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Convert Sorted Array to Binary Search Tree]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/26/convert-sorted-array-to-binary-search-tree/"/>
    <updated>2014-09-26T14:25:33+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/26/convert-sorted-array-to-binary-search-tree</id>
    <content type="html"><![CDATA[<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Definition for binary tree</span>
</span><span class='line'><span class="cm"> * struct TreeNode {</span>
</span><span class='line'><span class="cm"> *     int val;</span>
</span><span class='line'><span class="cm"> *     TreeNode *left;</span>
</span><span class='line'><span class="cm"> *     TreeNode *right;</span>
</span><span class='line'><span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span>
</span><span class='line'><span class="cm"> * };</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'>
</span><span class='line'> <span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'> <span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="n">TreeNode</span> <span class="o">*</span><span class="n">array2BST</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>      
</span><span class='line'>      <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="o">+</span><span class="n">end</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>      <span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]);</span>
</span><span class='line'>      <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">array2BST</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>      <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">array2BST</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">end</span><span class="p">);</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">TreeNode</span> <span class="o">*</span><span class="n">sortArrayToBST</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">array2BST</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Word Search]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/21/word-search/"/>
    <updated>2014-09-21T13:47:52+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/21/word-search</id>
    <content type="html"><![CDATA[<blockquote><p>Given a 2D board and a word, find if the word exists in the grid.</p>

<p>The word can be constructed from letters of sequentially adjacent cell, where &ldquo;adjacent&rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p>

<p>For example,<br/>
Given board =</p>

<pre><code>[
  ["ABCE"],
  ["SFCS"],
  ["ADEE"]
]   
</code></pre>

<p>word = <code>"ABCCED"</code>, -> returns <code>true</code>,<br/>
word = <code>"SEE"</code>, -> returns <code>true</code>,<br/>
word = <code>"ABCB"</code>, -> returns <code>false</code>.</p></blockquote>

<!--more-->


<p><strong>思路</strong><br/>
先在board中寻找word的首字母，找到后在该位置的相邻位置（上下左右）查看是否能生成word，如果上下左右中有位置符合条件，则继续从该位置的临近位置搜索下一个字符。主要，不能board中的字符不能重复使用，故需要将访问过的字符做标记，下面代码中设置为<code>‘#’</code>,对该位置搜索完后要恢复原来的字母。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">dfs</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">board</span><span class="p">,</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">,</span> <span class="n">string</span> <span class="n">word</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="n">word</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">char</span> <span class="n">ctmp</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">];</span>
</span><span class='line'>        <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;#&#39;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//向上查询</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">word</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">word</span><span class="p">,</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>         <span class="c1">//向下</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;=</span><span class="n">board</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">word</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span><span class="n">row</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">col</span><span class="p">,</span><span class="n">word</span><span class="p">,</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">//向左</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">word</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'>             <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">word</span><span class="p">,</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>        <span class="err">向右</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">word</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span><span class="n">row</span><span class="p">,</span><span class="n">col</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">word</span><span class="p">,</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//恢复原来的字母        </span>
</span><span class='line'>        <span class="n">board</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">ctmp</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">exist</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">const</span> <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">board</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>        <span class="k">const</span> <span class="kt">int</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">board</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">rows</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">cols</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">board</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">word</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">dfs</span><span class="p">(</span><span class="n">board</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">word</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
</span><span class='line'>                    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Palindrome Linklist]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/20/palindrome-linklist/"/>
    <updated>2014-09-20T00:00:00+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/20/palindrome-linklist</id>
    <content type="html"><![CDATA[<blockquote><p>2.7 Implement a function to check if a linked list is a palindrome.</p></blockquote>

<!--more-->


<h3>解法一  翻转链表得到新链表，再比较两个链表</h3>

<p>翻转链表的方法: 1）头插法  2）遍历加直接修改指针指向  3）递归</p>

<figure class='code'><figcaption><span>遍历加直接修改指针指向</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="n">ListNode8</span> <span class="n">ReverList</span><span class="err">（</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">pHead</span><span class="err">）</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">ListNode</span> <span class="o">*</span><span class="n">pNode</span> <span class="o">=</span> <span class="n">pHead</span><span class="p">;</span> <span class="c1">//当前结点</span>
</span><span class='line'>  <span class="n">ListNode</span> <span class="o">*</span><span class="n">pPrev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>  <span class="c1">//当前结点的前一个结点</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">pNode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">ListNode</span> <span class="o">*</span><span class="n">pNext</span> <span class="o">=</span> <span class="n">pNode</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>      <span class="n">PNode</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">pPrev</span><span class="p">;</span>
</span><span class='line'>      
</span><span class='line'>      <span class="n">pPrev</span> <span class="o">=</span> <span class="err"></span><span class="n">pNode</span><span class="p">;</span>
</span><span class='line'>      <span class="n">pNode</span>  <span class="o">=</span> <span class="n">pNext</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">pPrev</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p> <br/>
比较两个链表时，只需比较一半的元素即可，那么就要知道链表中间结点，可以通过快慢指针遍历一次得到中间结点，或者在比较的同时遍历。</p>

<figure class='code'><figcaption><span>比较到中间元素</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">bool</span> <span class="nf">isPalindrome</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">aHead</span><span class="p">.</span> <span class="n">ListNode</span> <span class="o">*</span><span class="n">bHead</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">ListNode</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">aHead</span><span class="p">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">ListNode</span> <span class="o">*</span><span class="n">pa</span> <span class="o">=</span> <span class="n">aHead</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ListNode</span> <span class="o">*</span><span class="n">pb</span> <span class="o">=</span> <span class="n">bhead</span><span class="p">;</span>     
</span><span class='line'>  
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span><span class="n">fast</span><span class="o">!</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pa</span> <span class="o">!=</span> <span class="o">*</span><span class="n">pb</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>      <span class="n">pa</span> <span class="o">=</span> <span class="n">pa</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>      <span class="n">pb</span> <span class="o">=</span> <span class="n">pb</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>解法二 利用栈来逆置前半个链表</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">bool</span> <span class="nf">isPlindrome</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">ListNode</span> <span class="o">*</span><span class="n">fast</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>  <span class="n">ListNode</span> <span class="o">*</span><span class="n">slow</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">//push elements from first half of linked lsit onto stack. When</span>
</span><span class='line'>  <span class="c1">//fast runner reaches the end of the linked list, then we know we&#39;re </span>
</span><span class='line'>  <span class="c1">//at the middle</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="n">a</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
</span><span class='line'>      <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>      <span class="n">fast</span> <span class="o">=</span> <span class="n">fast</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="c1">//the number of node is odd, skip the middle element</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">fast</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>      <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="n">slow</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">slow</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">a</span><span class="p">.</span><span class="n">top</span><span class="p">())</span>
</span><span class='line'>          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>      <span class="n">a</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'>      <span class="n">slow</span> <span class="o">=</span> <span class="n">slow</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>算法三 回溯法</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iqiyi2014年校招笔试 客户端开发工程师]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/19/iqiyi2014nian-xiao-zhao-bi-shi-ke-hu-duan-kai-fa-gong-cheng-shi/"/>
    <updated>2014-09-19T20:38:30+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/19/iqiyi2014nian-xiao-zhao-bi-shi-ke-hu-duan-kai-fa-gong-cheng-shi</id>
    <content type="html"><![CDATA[<p><img src="http://campus.iqiyi.com/html/images/index/logo.png" alt="" /> <br/>
先总结一下：考的内容比较基础，概率题不难，排序题不难，语法细节的题目较少，后面大题没有算法题，都是概念性的问题，复习的好的话应该不是问题，问题是我没有复习好<del>(>_&lt;)</del>。</p>

<!--more-->


<ol>
<li><p>在C和C++中，申请和释放内存的基本操作是什么，它们之间区别是什么？</p>

<hr />

<p> C语言提供内存动态分配的函数有：malloc、calloc、realloc，在使用这些念书时必须包含其头文件，分别为：<code>&lt;malloc.h&gt;,&lt;stdlib.h&gt;,&lt;alloc.h&gt;</code></p>

<ul>
<li>malloc 函数： <code>void *malloc(unsigned int size)</code>
在内存的动态分配区域中分配一个长度为size的连续空间。如果分配成功，则返回所分配内存空间的首地址，否则返回NULL，申请的内存不会进行初始化。“类型说明符”表示把该区域用于任何数据类型。（类型说明符 *）表示吧返回值强制转换为该类型的指针。 “size”是一个无符号数。</li>
<li>calloc 函数：<code>void *calloc(unsigned int num, unsigned int size)</code><br/>
按照所给的数据古树和数据类型所占字节数，分配一个num * size连续的空间。函数返回该存储区的其实地址。calloc函数与malloc函数的区别仅在于一次可以分配n块区域。例如 <code>ps=(struct stu *) calloc(2,sizeof (struct stu))</code>; 其中的<code>sizeof(struct stu)</code>是求stu的结构长度。因此该语句的意思是：按stu的长度分配2块连续区域，强制转换为stu类型，并把其首地址赋予指针变量ps。</li>
<li>realloc 函数：<code>void *realloc(void *ptr, unsigned int size)</code> <br/>
重新定义所开辟内存的空间的大小。其中ptr所指的内存空间是签署函数已经开辟的，size为新的空间大小，其值可比原来大或小。函数返回新存储区的起始地址（该地址可能与以前的地址不同）。例如p1=(float *)realloc(p1,16);将原先开辟的8个字节调整为16个字节。<br/>
<strong>动态申请的内存空间要进行手动用free（）函数释放</strong></li>
<li>free 函数 <code>void free(void *ptr)</code><br/>
将以前开辟的某内存空间释放，其中<code>ptr</code>为存放待释放空间起始地址的指针变量，函数无返回值。应注意：<code>ptr</code>指向需要释放的内存空间的首地址<br/>
<strong>C++</strong><br/>
在C++中，内存分为5个区，分别是堆，栈，自由存储区，全局/静态存储区，和常量存储区。<br/>
申请和释放堆中分诶的存储空间，分别使用new 和 delete 两个运算符来完成。<br/>
对于非内部数据类型对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free.</li>
</ul>
</li>
<li><p>分析采用线性表，二叉平衡树和哈希表存储数据的优劣。</p></li>
</ol>


<hr />

<p>   线性表分为顺序存储结构和链式存储结构，顺序存储结构的有点事可以实现随机读取，时间复杂度O(1)，空间利用率高；缺点是进行插入杀出操作时需要移动大量数据，时间复杂度为O(n),同时容量受限制，需要事先去顶容量大小，容量大浪费空间资源，过小产生溢出。链式存储结构有点，插入和删除非常简单，前提条件是知道要插入的位置，时间复杂度为O(1),但如果如果不知道插入位置，定位需要遍历链表，时间复杂度为O(n),优点是没有容量限制，可以在使用过程中动态分配内存，缺点是不能实现随机读取，空间利用率低。<br/>
二叉平衡树 的查找效率为O(logn),插入删除也是O(logn)，缺点是需要额外的指针空间。<br/>
哈希表O(1)时间做查找，插入和删除，时间复杂度为O(n)。</p>

<ol>
<li>strcpy是字符串拷贝函数，原型是<code>char *strcpy(char *strDest, const char *strSrc);</code><br/>
1) 请实现函数strcpy<br/>
2）strcpy能把strSrc的内容复制到StrDest，为什么还要 <code>char*</code>类型的返回值</li>
</ol>


<hr />

<p>1） 代码如下：需要注意的点:
* 检查指针的有效性，古国检查指针的有效性使用<code>((!strDes）&amp;&amp; (!strSrc))</code>,说明对C语言中类型的隐式转换没有深刻认识<code>(!strDest)</code>是将<code>char*</code>转换成bool即是类型隐式转换</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="nf">strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">strDest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strSrc</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">((</span><span class="n">strDest</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">strSrc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">));</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="n">strDest</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">strSrc</span> <span class="o">!=</span> <span class="err">&#39;</span><span class="o">/</span><span class="mi">0</span><span class="err">&#39;</span><span class="p">)</span>
</span><span class='line'>      <span class="o">*</span><span class="n">strDest</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">strSrc</span><span class="o">++</span><span class="p">;</span>             
</span><span class='line'>  <span class="o">*++</span><span class="n">strDest</span> <span class="o">=</span> <span class="err">&#39;</span><span class="o">/</span><span class="mi">0</span><span class="err">&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">address</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="nf">strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">strDest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strSrc</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">((</span><span class="n">strDest</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">strSrc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">));</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="n">strDest</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">strSrc</span> <span class="o">!=</span> <span class="err">&#39;</span><span class="o">/</span><span class="mi">0</span><span class="err">&#39;</span><span class="p">)</span>
</span><span class='line'>      <span class="o">*</span><span class="n">strDest</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">strSrc</span><span class="o">++</span><span class="p">;</span>             
</span><span class='line'>  <span class="o">*++</span><span class="n">strDest</span> <span class="o">=</span> <span class="err">&#39;</span><span class="o">/</span><span class="mi">0</span><span class="err">&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">address</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2) 返回 <code>char*</code>的指针是为了实现链式表达式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rotate List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/14/rotate-list/"/>
    <updated>2014-09-14T16:08:37+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/14/rotate-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a list, rotate the list to the right by k places, where k is non-negative.<br/>
For example:
Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> and <code>k = 2</code>,<br/>
return <code>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code>.</p></blockquote>

<!--more-->


<p><strong>思路</strong><br/>
有点感冒，头晕晕乎乎的，还出冷汗，一开始脑子不够用，竟然套用翻转string的那个算法，还reverse三次，弱爆了。其次就是<code>k</code>的值可能大于链表长度，我没有去算链表长度，直接用快慢指针做的，这样对于特殊输入运行效率可能极其低下，回头修改，写完这点，回宿舍休息会去。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Definition for singly-linked list.</span>
</span><span class='line'><span class="cm"> * struct ListNode {</span>
</span><span class='line'><span class="cm"> *     int val;</span>
</span><span class='line'><span class="cm"> *     ListNode *next;</span>
</span><span class='line'><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}</span>
</span><span class='line'><span class="cm"> * };</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">ListNode</span> <span class="o">*</span><span class="n">rotateRight</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">head</span> <span class="o">||</span> <span class="o">!</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">||</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>        <span class="n">ListNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">ListNode</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">ListNode</span> <span class="o">*</span><span class="n">newHead</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>        <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">newHead</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Triangle]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/12/triangle/"/>
    <updated>2014-09-12T17:40:54+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/12/triangle</id>
    <content type="html"><![CDATA[<blockquote><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>

<p>For example, given the following triangle</p>

<pre><code>    [
         [2],       
        [3,4],  
       [6,5,7],  
      [4,1,8,3]  
    ]   
</code></pre>

<p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>

<p>Note:<br/>
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p></blockquote>

<!--more-->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">minimumTotal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">triangle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minNums</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">minNums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">minNums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">minNums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">minNums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trapping Rain Water]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/12/trapping-rain-water/"/>
    <updated>2014-09-12T15:40:57+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/12/trapping-rain-water</id>
    <content type="html"><![CDATA[<blockquote><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>

<p>For example, <br/>
Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.</p>

<p><img src="http://www.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt="" /><br/>
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p></blockquote>

<!--more-->




<figure class='code'><figcaption><span>时间复杂度O(n), 空间复杂度O(1)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">trap</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">leftMax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">rightMax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">leftMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">leftMax</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">]);</span>
</span><span class='line'>            <span class="n">rightMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">rightMax</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">leftMax</span> <span class="o">&lt;</span> <span class="n">rightMax</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">value</span> <span class="o">+=</span> <span class="n">leftMax</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
</span><span class='line'>                <span class="n">l</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">value</span> <span class="o">+=</span> <span class="n">rightMax</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">];</span>
</span><span class='line'>                <span class="n">r</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
</feed>
