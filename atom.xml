<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Progressing Blog]]></title>
  <link href="http://michaelpassion.github.io/atom.xml" rel="self"/>
  <link href="http://michaelpassion.github.io/"/>
  <updated>2014-09-20T09:46:06+08:00</updated>
  <id>http://michaelpassion.github.io/</id>
  <author>
    <name><![CDATA[Michael]]></name>
    <email><![CDATA[carter1373043@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iqiyi2014年校招笔试 客户端开发工程师]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/19/iqiyi2014nian-xiao-zhao-bi-shi-ke-hu-duan-kai-fa-gong-cheng-shi/"/>
    <updated>2014-09-19T20:38:30+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/19/iqiyi2014nian-xiao-zhao-bi-shi-ke-hu-duan-kai-fa-gong-cheng-shi</id>
    <content type="html"><![CDATA[<p><img src="http://campus.iqiyi.com/html/images/index/logo.png" alt="" /> <br/>
先总结一下：考的内容比较基础，概率题不难，排序题不难，语法细节的题目较少，后面大题没有算法题，都是概念性的问题，复习的好的话应该不是问题，问题是我没有复习好<del>(>_&lt;)</del>。</p>

<!--more-->


<ol>
<li><p>在C和C++中，申请和释放内存的基本操作是什么，它们之间区别是什么？</p>

<hr />

<p> C语言提供内存动态分配的函数有：malloc、calloc、realloc，在使用这些念书时必须包含其头文件，分别为：<code>&lt;malloc.h&gt;,&lt;stdlib.h&gt;,&lt;alloc.h&gt;</code></p>

<ul>
<li>malloc 函数： <code>void *malloc(unsigned int size)</code>
在内存的动态分配区域中分配一个长度为size的连续空间。如果分配成功，则返回所分配内存空间的首地址，否则返回NULL，申请的内存不会进行初始化。“类型说明符”表示把该区域用于任何数据类型。（类型说明符 *）表示吧返回值强制转换为该类型的指针。 “size”是一个无符号数。</li>
<li>calloc 函数：<code>void *calloc(unsigned int num, unsigned int size)</code><br/>
按照所给的数据古树和数据类型所占字节数，分配一个num * size连续的空间。函数返回该存储区的其实地址。calloc函数与malloc函数的区别仅在于一次可以分配n块区域。例如 <code>ps=(struct stu *) calloc(2,sizeof (struct stu))</code>; 其中的<code>sizeof(struct stu)</code>是求stu的结构长度。因此该语句的意思是：按stu的长度分配2块连续区域，强制转换为stu类型，并把其首地址赋予指针变量ps。</li>
<li>realloc 函数：<code>void *realloc(void *ptr, unsigned int size)</code> <br/>
重新定义所开辟内存的空间的大小。其中ptr所指的内存空间是签署函数已经开辟的，size为新的空间大小，其值可比原来大或小。函数返回新存储区的起始地址（该地址可能与以前的地址不同）。例如p1=(float *)realloc(p1,16);将原先开辟的8个字节调整为16个字节。<br/>
<strong>动态申请的内存空间要进行手动用free（）函数释放</strong></li>
<li>free 函数 <code>void free(void *ptr)</code><br/>
将以前开辟的某内存空间释放，其中<code>ptr</code>为存放待释放空间起始地址的指针变量，函数无返回值。应注意：<code>ptr</code>指向需要释放的内存空间的首地址<br/>
<strong>C++</strong><br/>
在C++中，内存分为5个区，分别是堆，栈，自由存储区，全局/静态存储区，和常量存储区。<br/>
申请和释放堆中分诶的存储空间，分别使用new 和 delete 两个运算符来完成。<br/>
对于非内部数据类型对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free.</li>
</ul>
</li>
<li><p>分析采用线性表，二叉平衡树和哈希表存储数据的优劣。</p></li>
</ol>


<hr />

<p>   线性表分为顺序存储结构和链式存储结构，顺序存储结构的有点事可以实现随机读取，时间复杂度O(1)，空间利用率高；缺点是进行插入杀出操作时需要移动大量数据，时间复杂度为O(n),同时容量受限制，需要事先去顶容量大小，容量大浪费空间资源，过小产生溢出。链式存储结构有点，插入和删除非常简单，前提条件是知道要插入的位置，时间复杂度为O(1),但如果如果不知道插入位置，定位需要遍历链表，时间复杂度为O(n),优点是没有容量限制，可以在使用过程中动态分配内存，缺点是不能实现随机读取，空间利用率低。<br/>
二叉平衡树 的查找效率为O(logn),插入删除也是O(logn)，缺点是需要额外的指针空间。<br/>
哈希表O(1)时间做查找，插入和删除，时间复杂度为O(n)。</p>

<ol>
<li>strcpy是字符串拷贝函数，原型是<code>char *strcpy(char *strDest, const char *strSrc);</code><br/>
1) 请实现函数strcpy<br/>
2）strcpy能把strSrc的内容复制到StrDest，为什么还要 <code>char*</code>类型的返回值</li>
</ol>


<hr />

<p>1） 代码如下：需要注意的点:
* 检查指针的有效性，古国检查指针的有效性使用<code>((!strDes）&amp;&amp; (!strSrc))</code>,说明对C语言中类型的隐式转换没有深刻认识<code>(!strDest)</code>是将<code>char*</code>转换成bool即是类型隐式转换</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="nf">strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">strDest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strSrc</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">((</span><span class="n">strDest</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">strSrc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">));</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="n">strDest</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">strSrc</span> <span class="o">!=</span> <span class="err">&#39;</span><span class="o">/</span><span class="mi">0</span><span class="err">&#39;</span><span class="p">)</span>
</span><span class='line'>      <span class="o">*</span><span class="n">strDest</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">strSrc</span><span class="o">++</span><span class="p">;</span>             
</span><span class='line'>  <span class="o">*++</span><span class="n">strDest</span> <span class="o">=</span> <span class="err">&#39;</span><span class="o">/</span><span class="mi">0</span><span class="err">&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">address</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="nf">strcpy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">strDest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strSrc</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">((</span><span class="n">strDest</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">strSrc</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">));</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">address</span> <span class="o">=</span> <span class="n">strDest</span><span class="p">;</span>
</span><span class='line'>  <span class="k">while</span><span class="p">(</span><span class="o">*</span><span class="n">strSrc</span> <span class="o">!=</span> <span class="err">&#39;</span><span class="o">/</span><span class="mi">0</span><span class="err">&#39;</span><span class="p">)</span>
</span><span class='line'>      <span class="o">*</span><span class="n">strDest</span><span class="o">++</span> <span class="o">=</span> <span class="o">*</span><span class="n">strSrc</span><span class="o">++</span><span class="p">;</span>             
</span><span class='line'>  <span class="o">*++</span><span class="n">strDest</span> <span class="o">=</span> <span class="err">&#39;</span><span class="o">/</span><span class="mi">0</span><span class="err">&#39;</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">address</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>2) 返回 <code>char*</code>的指针是为了实现链式表达式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rotate List]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/14/rotate-list/"/>
    <updated>2014-09-14T16:08:37+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/14/rotate-list</id>
    <content type="html"><![CDATA[<blockquote><p>Given a list, rotate the list to the right by k places, where k is non-negative.<br/>
For example:
Given <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code> and <code>k = 2</code>,<br/>
return <code>4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</code>.</p></blockquote>

<!--more-->


<p><strong>思路</strong><br/>
有点感冒，头晕晕乎乎的，还出冷汗，一开始脑子不够用，竟然套用翻转string的那个算法，还reverse三次，弱爆了。其次就是<code>k</code>的值可能大于链表长度，我没有去算链表长度，直接用快慢指针做的，这样对于特殊输入运行效率可能极其低下，回头修改，写完这点，回宿舍休息会去。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * Definition for singly-linked list.</span>
</span><span class='line'><span class="cm"> * struct ListNode {</span>
</span><span class='line'><span class="cm"> *     int val;</span>
</span><span class='line'><span class="cm"> *     ListNode *next;</span>
</span><span class='line'><span class="cm"> *     ListNode(int x) : val(x), next(NULL) {}</span>
</span><span class='line'><span class="cm"> * };</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">ListNode</span> <span class="o">*</span><span class="n">rotateRight</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">head</span> <span class="o">||</span> <span class="o">!</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">||</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>        <span class="n">ListNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">k</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">ListNode</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>            <span class="n">q</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">ListNode</span> <span class="o">*</span><span class="n">newHead</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
</span><span class='line'>        <span class="n">q</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">newHead</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Triangle]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/12/triangle/"/>
    <updated>2014-09-12T17:40:54+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/12/triangle</id>
    <content type="html"><![CDATA[<blockquote><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p>

<p>For example, given the following triangle</p>

<pre><code>    [
         [2],       
        [3,4],  
       [6,5,7],  
      [4,1,8,3]  
    ]   
</code></pre>

<p>The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</p>

<p>Note:<br/>
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</p></blockquote>

<!--more-->




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">minimumTotal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">triangle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">minNums</span> <span class="o">=</span> <span class="n">triangle</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">minNums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">minNums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">minNums</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">triangle</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">minNums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trapping Rain Water]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/12/trapping-rain-water/"/>
    <updated>2014-09-12T15:40:57+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/12/trapping-rain-water</id>
    <content type="html"><![CDATA[<blockquote><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</p>

<p>For example, <br/>
Given <code>[0,1,0,2,1,0,1,3,2,1,2,1]</code>, return <code>6</code>.</p>

<p><img src="http://www.leetcode.com/wp-content/uploads/2012/08/rainwatertrap.png" alt="" /><br/>
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p></blockquote>

<!--more-->




<figure class='code'><figcaption><span>时间复杂度O(n), 空间复杂度O(1)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">trap</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">leftMax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">rightMax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">leftMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">leftMax</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">]);</span>
</span><span class='line'>            <span class="n">rightMax</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">rightMax</span><span class="p">,</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">leftMax</span> <span class="o">&lt;</span> <span class="n">rightMax</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">value</span> <span class="o">+=</span> <span class="n">leftMax</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">l</span><span class="p">];</span>
</span><span class='line'>                <span class="n">l</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">value</span> <span class="o">+=</span> <span class="n">rightMax</span> <span class="o">-</span> <span class="n">A</span><span class="p">[</span><span class="n">r</span><span class="p">];</span>
</span><span class='line'>                <span class="n">r</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Permutation Sequence]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/11/permutation-sequence/"/>
    <updated>2014-09-11T23:48:20+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/11/permutation-sequence</id>
    <content type="html"><![CDATA[<blockquote><p>The set [1,2,3,…,n] contains a total of n! unique permutations.</p>

<p>By listing and labeling all of the permutations in order,
We get the following sequence (ie, for n = 3):</p>

<ol>
<li>&ldquo;123&rdquo;</li>
<li>&ldquo;132&rdquo;</li>
<li>&ldquo;213&rdquo;</li>
<li>&ldquo;231&rdquo;</li>
<li>&ldquo;312&rdquo;</li>
<li>&ldquo;321&rdquo;</li>
</ol>


<p>Given n and k, return the k-th permutation sequence.</p>

<p>Note: Given n will be between 1 and 9 inclusive.</p></blockquote>

<!--more-->


<figure class='code'><figcaption><span>时间复杂度O(n),空间复杂度O(1)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span> <span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>            <span class="n">res</span> <span class="o">*=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">string</span> <span class="n">getPermutation</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class='line'>          <span class="n">string</span> <span class="n">candidate</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="s">&quot;123456789&quot;</span><span class="p">).</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
</span><span class='line'>          <span class="n">string</span> <span class="nf">res</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="sc">&#39; &#39;</span><span class="p">);</span>
</span><span class='line'>          <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="c1">//依次计算排列的每个位</span>
</span><span class='line'>          <span class="p">{</span>
</span><span class='line'>              <span class="n">total</span> <span class="o">/=</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="p">);</span>
</span><span class='line'>             <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">total</span><span class="p">;</span>
</span><span class='line'>             <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
</span><span class='line'>             <span class="n">candidate</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>             <span class="n">k</span> <span class="o">-=</span> <span class="n">index</span><span class="o">*</span><span class="n">total</span><span class="p">;</span>
</span><span class='line'>         <span class="p">}</span>
</span><span class='line'>         <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique Character in a String]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/11/unique-character-in-a-string/"/>
    <updated>2014-09-11T17:34:37+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/11/unique-character-in-a-string</id>
    <content type="html"><![CDATA[<blockquote><p>Implement an algorithm to determine if a string has all unique characters. What if you cannot use additional data structures?</p></blockquote>

<!--more-->




<figure class='code'><figcaption><span>空间复杂度O(1),时间复杂度O(n)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">bool</span> <span class="nf">isUnique</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">//以ASCII讨论，ASCII总数为256，如果字符串的长度大于256，</span>
</span><span class='line'>                               <span class="c1">//肯定有重复字符</span>
</span><span class='line'>  <span class="kt">bool</span> <span class="n">check</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
</span><span class='line'>  <span class="n">memset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="nb">false</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span><span class="p">(</span><span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span><span class='line'>          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>      <span class="n">check</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
如果字符串中所有字符全是小写字母（a-z）,字符总数为26，为节省空间，还可以将字符映射到int的每一位上。</p>

<figure class='code'><figcaption><span>空间复杂度O(1),时间复杂度O(n) 位操作</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="kt">bool</span> <span class="nf">isUnique</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">26</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kt">int</span> <span class="n">checker</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="sc">&#39;a&#39;</span><span class="p">;</span>
</span><span class='line'>      <span class="k">if</span><span class="p">((</span><span class="n">checker</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">val</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>      <span class="n">checker</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">val</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Search Insert Position]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/11/search-insert-position/"/>
    <updated>2014-09-11T11:51:00+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/11/search-insert-position</id>
    <content type="html"><![CDATA[<blockquote><p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>

<p>You may assume no duplicates in the array.</p>

<p>Here are few examples.<br/>
    [1,3,5,6], 5 → 2<br/>
    [1,3,5,6], 2 → 1<br/>
    [1,3,5,6], 7 → 4<br/>
    [1,3,5,6], 0 → 0</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/search-insert-position/">leetcode express</a></p>

<p><strong>思路</strong><br/>
首先这题肯定用二分查找，因为给定数组是有序的，与二分不同的是如果数组中没有target要返回target应该插入的位置。在二分查找中如果没有找到target则返回-1，此时，l>r（l,r分别为标记查找范围的左指针和右指针）,而此时l = r+1, 由题目给出几组数据可知，此时l的位置就是target要应该插入的位置。</p>

<figure class='code'><figcaption><span>时间复杂度O(logn),空间复杂度O(1)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">searchInsert</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">mid</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">while</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">mid</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">((</span><span class="n">r</span><span class="o">-</span><span class="n">l</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
</span><span class='line'>                <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span>
</span><span class='line'>                <span class="n">l</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">l</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>扩展</strong><br/>
如果数组中有重复数字，且要求将target插入到数组中，并要在相同数字第一个位置之前，怎么设计算法？ <br/>
to be continued&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Search a 2D Matrix]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/04/search-a-2d-matrix/"/>
    <updated>2014-09-04T10:50:42+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/04/search-a-2d-matrix</id>
    <content type="html"><![CDATA[<blockquote><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p>

<ul>
<li>Integers in each row are sorted from left to right.</li>
<li>The first integer of each row is greater than the last integer of the previous row.</li>
</ul>


<p>For example,</p>

<p>Consider the following matrix:</p></blockquote>

<pre><code>[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
</code></pre>

<blockquote><p>Given target = <code>3</code>, return <code>true</code>.</p></blockquote>

<!-- more-->


<p><a href="https://oj.leetcode.com/problems/search-a-2d-matrix/">leetcode express</a></p>

<p><strong>方法一</strong><br/>
先查找target可能在的行，再从行中找target</p>

<figure class='code'><figcaption><span>二分 时间复杂度 O(logm+logn)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">searchMatrix</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//注意low从1开始</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">row</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span><span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>           <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">mid</span> <span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
</span><span class='line'>                <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="k">else</span>
</span><span class='line'>                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">row</span> <span class="o">=</span> <span class="n">high</span><span class="p">;</span>
</span><span class='line'>        <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">high</span> <span class="o">=</span> <span class="n">col</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span><span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span><span class="o">+</span><span class="n">high</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
</span><span class='line'>                <span class="n">high</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="k">else</span>
</span><span class='line'>                <span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>方法二</strong></p>

<p>这个方法还没有第一个方法好。</p>

<figure class='code'><figcaption><span>时间复杂度O(n*logm)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">searchMatrix</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">matrix</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="p">;)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">col</span><span class="p">;</span>
</span><span class='line'>                <span class="k">while</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">)</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
</span><span class='line'>                    <span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
</span><span class='line'>                        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>                    <span class="k">if</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
</span><span class='line'>                        <span class="n">r</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>                    <span class="k">else</span>
</span><span class='line'>                        <span class="n">l</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Red-Black Trees]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/09/02/red-black-trees/"/>
    <updated>2014-09-02T21:05:51+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/09/02/red-black-trees</id>
    <content type="html"><![CDATA[<p><strong>红黑树介绍</strong></p>

<hr />

<p>红黑树是一种儿茶查找树，但在每个节点上增加一个存储位表示节点的颜色，可以是Red或是Black。
通过对任何一条从跟到叶子节点的路径上各个节点着色方式的限制，红黑树确保没有一条路径会比其他路径长两倍，因而是接近平衡的。</p>

<h3>二叉查找树的性质</h3>

<p>二叉查找树（Binary Search Tree）,也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p>

<ul>
<li>若任意节点的左子树不空，则左子树上的所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点得值；</li>
<li>任意节点的左右子树也分别为二叉查找树。</li>
<li>没有键值相等的结点 （no duplicate node）</li>
</ul>


<p> 对于红黑树，能保证在最坏情况下，基本的动态几何操作的时间均为 <code>O(lgn)</code>。</p>

<p> ###红黑树</p>

<p>红黑树，本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。<br/>
红黑树的五条性质：<br/>
    1. 每个结点要么是红的，要么是黑的。
    2. 根节点是黑的。
    3. 每个叶节点（叶结点即指树尾端NIL指针或NULL节点）是黑的。
    4. 如果一个结点是和哦你给的，那么它的两个子节点都是黑的。
    5. 对于任一结点而言，祈祷叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。</p>

<p><img src="http://zh.wikipedia.org/wiki/File:Red-black_tree_example.svg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I Don't Have Time]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/29/i-dont-have-time/"/>
    <updated>2014-08-29T10:16:11+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/29/i-dont-have-time</id>
    <content type="html"><![CDATA[<blockquote><p>Is there something you&rsquo;d like to create? A project you want to build? A goal you want to achieve?</p></blockquote>

<!--more-->


<p><a href="http://www.mdswanson.com/blog/2012/10/28/i-dont-have-time.html">Original Link</a></p>

<hr />

<p>Is there something you&rsquo;d like to create? A project you want to build? A goal you want to achieve?</p>

<p>With the likes of <a href="http://www.gladwell.com/outliers/outliers_excerpt1.html">Malcolm Gladwell</a> and <a href="http://norvig.com/21-days.html">Peter Norvig</a> telling us that it takes
thousands of hours and many years to master something, your dreams and ambitions can
easily stall as reality sinks in.</p>

<p>How do you get the inertia to start when the finish line seems so far away?</p>

<blockquote><p>I&rsquo;d like to write a book, but I don&rsquo;t have time to do all that work.</p></blockquote>

<p>But do you have an hour to outline a table of contents? Could you write 500
words today? How about emailing five bloggers that might be interested in reviewing your
book this week?</p>

<p><a href="http://nathanbarry.com/">Nathan Barry</a>, a normal guy from Idaho with a wife and kid, found the time to write
his book in <a href="http://nathanbarry.com/commitment-changed-career/">thousand word chunks</a>.</p>

<blockquote><p>I&rsquo;d really like to start drawing, but I&rsquo;m no good and don&rsquo;t have time to learn.</p></blockquote>

<p>Do you have time to draw one sketch today? And again tomorrow? Could you steal enough
time to read a chapter in a <a href="http://www.drawright.com/">book</a> every week? To visit an art museum once a month?</p>

<p><a href="http://www.jonathanhardesty.com/">Jonathan Hardesty</a>, an aspiring artist who started at &ldquo;rock bottom&rdquo;, did
one sketch or painting <a href="http://conceptart.org/forums/showthread.php?870">every day</a>. It took him years of work, but he went
from untrained to professional artist.</p>

<blockquote><p>I love documentaries and want to make my own someday, but I don&rsquo;t think I&rsquo;ll ever find the time.</p></blockquote>

<p>Can you send an email to a subject you want to interview today? Could you edit just one
interview this week? Do you have a free weekend to film B-roll next month?</p>

<p><a href="http://timcawley.blogspot.com/">Tim Cawley</a>, with a day job in advertising, squeezed in work on nights, early
mornings, and holiday breaks for two years to complete <a href="http://fromnothingsomething.com/">his documentary</a>. It&rsquo;s now
showing at film festivals across the country.</p>

<hr />

<p>Gradual progress is crazy powerful.</p>

<p>When you frame something as a giant, amorphous task (get healthy, become a designer,
start a business) &mdash; it can seem impossible to fit into your busy schedule.</p>

<p>Break it down into smaller pieces that you do have time for.</p>

<p>With time and determination, the <strong>impossible</strong> will become the <strong>inevitable</strong>.</p>

<hr />

<p>总是觉得自己心比天高，命比纸薄。想学好多东西，也总有无从下手，觉得自己既没有天分，又下不了决心。其实是不够勇敢，执行力不够，再加拖延。正如文章所述：循序渐进的力量异常强大。当你规划某些庞大，杂乱无杂的计划时，你根本不可能将这些事加入你的“满满”的时间表中。但是如果你将他们分解，细化成你可以抽时间去做的小任务，再加上一点点时间和不放弃的决心，<strong>不可能</strong>就会成为<strong>必然</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阿里实习生研发工程师面试经验分享]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/28/a-li-shi-xi-sheng-yan-fa-gong-cheng-shi-mian-shi-jing-yan-fen-xiang/"/>
    <updated>2014-08-28T17:26:42+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/28/a-li-shi-xi-sheng-yan-fa-gong-cheng-shi-mian-shi-jing-yan-fen-xiang</id>
    <content type="html"><![CDATA[<blockquote><p>看到人家写的面试经验，觉得自己真是干啥啥不行吃啥啥不剩的主，本科四年昏昏沉沉就过去了，可是研究生呢？也长多少本事，要是能把长在身上的肉全换成本事就好了。越说越伤心，放在这里，激励下自己，也把面经里面的知识点做下巩固吧。</p></blockquote>

<!--more-->


<p><a href="http://www.itmian4.com/forum.php?mod=viewthread&amp;tid=4800#lastpost">原文链接</a><br/>
时间：2014年4月</p>

<p>地点：武汉</p>

<p>岗位：研发工程师</p>

<p>一、      笔试：</p>

<p>首先简单的说一下阿里的笔试题，笔试实在3月29号晚上，全国统考，刚好那天下午是TX的笔试，一天考两场，而且考场在不同学校，还是蛮累的。阿里的题首先是20道单选，然后是4道不定向选择，然后是填空题和简答题。还有一道java方向的附加题，监考人员说明阿里需要大量的java工程师。感觉比TX的题好做，考试范围相对没TX那么广，阿里很喜欢考概率题，这次不下于三道吧，还有智力题，没有编程题。总体而言难度还好，但感觉刷人刷的比较明显。然后后面一个月开始了全国各大城市的面试之旅，每个城市都是待两天吧。武汉在行程安排上是最后一站，所以直到24号才面试，时间有点久。之前刚好已完成TX的面试，也算有了一些经验。</p>

<p>二、      一面：</p>

<p>面试地点是君宜王朝大饭店，不是面试，还真没机会进去，-_-。中午12：20到酒店后，先签到，签到的时候会问你面什么方向，C++还是java，貌似还有一小部分是C语言。签完到，在大厅等，有水还有小吃，和旁边一起等的哥们瞎扯。期间得知此次武汉站阿里不接受霸面，给出了理由是时间和面试官有限，不过还是把简历收了，如果合适估计还是会给机会面试。大概不到1点的时候通知去一面。一面在一个大房间，很多小桌子围成一圈，1V1。</p>

<ol>
<li><p>简单的自我介绍，对参加的竞赛了解了下。</p></li>
<li><p>项目上的改进，有什么应用呢？项目怎么做的，说流程，并基于内容提了几个问题。</p></li>
<li><p>在地图上给定两个点，怎么搜索从一个点到另一个点的最优路径。直接回答搜索算法比较好的应该是A<em>启发式搜索，然后问A</em>是基于广搜还是深搜的，回答基于广搜。再问还会哪些其他搜索算法，说一下具体实现。就简单的回答Dij，DFS，BFS的实现关键点。</p></li>
<li><p>C++基础：多态怎么实现的，多态的内存分布，构造函数可以是虚函数吗? 画内存分布图说明。</p></li>
</ol>


<p>构造函数可以调用虚函数吗，编译能通过吗？可以运行吗？我说我知道这样调用是肯定有问题的，我肯定不会这么用，因为先调用基类构造函数，再调用子类，如果在基类构造函数中调用虚函数，此时虚表还未建立完整，调用子类虚函数肯定有问题，但这样能不能编译就不确定了，感觉可以编译，有点不确定。</p>

<p>面试官笑着说你回去试试吧。回来查了下编译是可以通过的，但是运行出来的结果是不确定的。</p>

<ol>
<li>算法：知道哪些排序算法，堆排序、归并排序、快排的时间复杂度各是多少，分析平均时间和最坏时间复杂度，快排怎么实现的。</li>
</ol>


<p>给定一个已经排序的数组，然后统计其中出现次数最多的那个数，写代码，还因为最后那个字符是否考虑到了有个讨论，的确是考虑到了，然后他觉得没考虑到，就说要是让你输出所有统计次数呢，继续改代码，这次的确最后一个数在else里面没统计进去，但是与max的比较是在if/else之外啊，的确与max比较了，好吧，然后就没深究了。</p>

<ol>
<li>STL: 知道vector吗，一个自然数数组，要删除其中的奇数，写出代码。这个需要注意的是erase删除结点，则该结点的iterator会失效，同时erase会返回下一个有效迭代器，所以iter++只有在偶数的时候才运行。</li>
</ol>


<p>继续问到iter++和++iter的区别，回答前者会产生一个临时变量，后者的效率更高，如果前面有=的话，得到的值不一样。</p>

<p>vector是怎么存储的，如果让你实现vector，你怎么做，首先说了下STL里面的vector，内存如何分配的，构造函数等等。开始用数组实现vector，然后问一定要写成类似MS提供的STL里面的vector，提示说不用，写个基本框架就可以了，就直接写vector代码，然后写vector的插入操作，注意vector满时要重新分配两倍的内存空间，将原数组拷贝进去。</p>

<p>vector是线程安全的吗，解释了下，貌似我没说出本质，有点犹豫，然后说要是多线程操作vector的插入操作，会不会有问题。这个其实和两个线程同时对一个变量进行赋值一样的，所以肯定是不安全的，需要加锁，有可能插入两个数据了，而finish就加了一次这种问题。</p>

<p>期间问到有没有看过STL源码，回答看过，对STL里面各种编程思想感触很深。</p>

<ol>
<li><p>计算机网络：三次握手，四次挥手，握手阶段什么时候可以传数据，四次挥手为什么客户端要再等待一会？画图说明就可以了。</p></li>
<li><p>操作系统：进程和线程是什么，区别，多线程知道多少，互斥量、事件、信号量怎样用，（我说还有临界区CRITICAL_SECTION，他没明白，貌似他没用过，囧）。</p></li>
</ol>


<p>现场写一个生产者消费者多线程程序，我写了一个生产者一个消费者的，然后问怎么优化，第一时间还以为要从算法的角度去考虑优化，提示说高并发，然后我就说用信号量可以实现并发，多个生产者和多个消费者，既有同步也有互斥，balabala解释一阵。</p>

<ol>
<li><p>linux下的命令行知道多少，top命令用过没有，fork()函数用过没有，说了下，简历上写用过gdb调试，问如果用gdb调试像fork()这样的多线程怎么调试，直接说只调试过单线程，这个真没试过，囧&hellip;gdb怎么调试，我说，加断点，然后单步调试如何如何，然后问，你觉得多线程里面的断点调试怎么实现的。好吧，这个问题还真没想过，想了下，我说执行到断点就线程挂起，然后等待执行下一步的命令来唤醒线程。不知道回答的对不对。</p></li>
<li><p>大数据：给定1G文本，文本每行是一个单词，现在可用内存很少，假设1M，怎么统计文本中出现频率最多的10个单词。TOP K问题，回答类似map-reduce，分而治之，将大文本分为多个小文本，即使用hash函数将相同hash值的单词分到同一子文本，直到内存能装下，再hashmap统计次数，最后建立元素为10的最小堆，即可完成。问这样分成多个小文本IO开销太大了吧，回答是的&hellip;然后问这个算法的时间复杂度，解释了下统计和堆的时间。</p></li>
<li><p>开放性问题1：你是怎么学习C++的？首先是先看书，C++ primer和深度探索C++对象模型都看了几遍，然后自己对不懂的地方在网上查资料，同时自己编写小的演示程序来测试，更直观的是反汇编，看汇编代码，总之一定要搞清楚研究的对象在内存上是怎么存储的。然后又以虚函数为例说明了下。</p></li>
</ol>


<p>开放性问题2：除了学C++外，你还学过或者想学哪些其他的东西。回答想学nginx，问为什么要学这个，我说nginx已经被阿里腾讯等大公司所使用，尽管是web服务器，但是它里面使用的多线程高并发和内存池等知识都有很好的学习价值，有必要扩展自己的视野。算是闲扯。</p>

<ol>
<li><p>了解到我研究生的研究方向是图像处理中的模式识别这块，就问如何实现车牌识别，你觉得应该怎样做。这个的确没有做过相关的，从一般的处理方法出来，车牌字符比较大，而且边缘明显，所以用滤波加二值化和膨胀等形态学处理应该就可以得到，可能效果不好。复杂一点的就是提典型特征+神经网络SVM等分类器了。大致描述了一下流程，然后就没多问了。期间还问了发表的两篇文章是做的什么，稍微说明了一下。</p></li>
<li><p>以后要做什么方向，系统还是业务，客户端还是服务器端，假如要你来阿里做java愿不愿意，算是闲聊，同时了解了下阿里的业务。不了解的可以叫他介绍下各是干啥，说下自己的想法，随机应变。</p></li>
</ol>


<p>面试一个小时10分钟左右，旁边的那个面试官都换了两个人了，我还坐在那说，最后面试官终于开口说没问题了。</p>

<p>总结：只要你敢写在简历上，他就敢问，当然一面问的的确够基础，要求写出代码的一定要保证正确，编程习惯也要良好，对输入的指针进行判断，只要的东西最好用图示展示清楚，开放性问题考察时间规划和思维运转，总之不能冷场，最好是能说点东西出来。</p>

<p>三、       二面：</p>

<p>一面结束后，出来等结果，工作人员会告诉你，要是继续等下一轮面试就表示面试通过，要是说回去等通知就是跪了，这时在来往上是可以查到自己的状态的。出来后通知过两个小时面二面。之前有同学说阿里就二面，第二面是技术面试官和HR一起面，而且二面主要倾向于项目这块，然后就在大厅等，等的差点睡着，后来和旁边的哥们闲扯了下，终于在5点的时候通知去二面。二面在上次参加宣讲的会议室，大多数是一个技术面试官和一个HR面试官一起2V1。</p>

<p>顺便提一下阿里的宣讲，一个多月前打电话给内推的同学去参加，去了后发现只有我们学校的，是专场，大概就50人的样子，形式与其他公司有点小区别，不过觉得这样一个讨论的过程还不错。最后大家分组还讨论了一道题。</p>

<p>二面面试官那居然只有一个人，惊了个呆，了解到HR不够，所以就没有HR参与这轮面试。好吧。</p>

<ol>
<li><p>简单的自我介绍。</p></li>
<li><p>果然是项目，说一下你认为印象最深刻的项目详细说一下。然后和面试官讨论，问应用方向，问具体的优化，各种细节吧。这个自己做过的项目，说起来还是比较容易的。讨论时间有点长。</p></li>
<li><p>STL会是吧，那写个stack的实现代码，最好不要用其他容器。好吧，我还想要不直接用deque来实现，又觉得没必要搞这么麻烦，还是用数组吧，然后写push,top,pop，主要也就是注意下栈满和空的时候。写完讨论了下也没再问了。</p></li>
<li><p>多线程了解多少，好吧，那就从最简单的线程进程说起，区别联系，说完以后，问就拿今天面试官与面试者来说，假设m个面试者,n个面试官，你写个多线程并发的程序来描述这个过程，可以写伪代码。这个其实还好，创建资源为n的信号量，即可实现。</p></li>
<li><p>说说你对面向对象的理解。首先面向对象的三大特性和6大原则，每个再稍微啰嗦两句，再结合一下平时编程的心得大致谈谈。</p></li>
<li><p>又问到图像上的文本识别问题，好吧，结合对图像处理的理解，说了几种方法，也不知道面试官自己懂的多不多。可能也是考察能不能活学活用吧。</p></li>
<li><p>最后感觉面试官可能有点累了，说话不多，也不提问，在电脑上记录什么，有点尴尬，然后我就说我能不能问个问题，他说可以啊，我就说阿里的共享业务事业部是干啥的，为何它和聚划算啊天猫啊淘宝啊等等业务都有关系，他来了句“你还知道共享业务事业部啊”，囧，然后给我介绍了下中间件，以及大致的业务运转流程。解释完问还有没有问题，我说没有了，他说那差不多行了。</p></li>
</ol>


<p>总结：二面问基础问的不多，而是偏重于你实际的项目，所以不管你项目做的什么，一定都要对整个流程有细致的把握，这样无论问哪个方面，都可以根据实际情况回答，还可以根据面试官的提示对细节进行改进，一个讨论的过程。</p>

<p>四、       三面：</p>

<p>二面结束的时候，问二面面试官，是否二面就是终面，他说是的，但是如果你两次面试都是A，就还有一轮交叉面。听起来很高端，然后出来等，那时候已经6点多了。过了会，工作人员找到我说你还有一轮要面，问是否今天面，还是明天面，果断明天面，今天再面下去还不得崩溃。</p>

<p>第二天早上10点下大雨，到老地方签到等，第二天来面试的人已经很少了，大厅等的人没几个，而且在签到表上没看到别的来面交叉面的。在10：30的时候，通知去面试，然后私下问了下工作人员，不是只有两轮面试吗，为何还有交叉面，这是啥面试。他说证明你不错，公司想进一步了解你，所以就加面了。进去后，发现是一个技术面试官和一个HR。</p>

<p>面试流程还是自我介绍，问项目，说一个最熟悉的项目，然后讨论；叫我写vector实现；如何写多线程，项目中怎么用的，进一步讨论；最后又是图像上水印文本的识别。好吧，整个技术面和第二面没太多区别，就不多写了。大概面了半小时，HR姐姐发话了，然后开始了最虐心的一轮面试。</p>

<p>HR姐姐的问题主要有：</p>

<ol>
<li><p>说一下你的成长经历。我就从家庭情况说起，中学，大学，研究生阶段。其中提到爸妈现在在杭州。最后发现这句话还是很关键的。哈哈。</p></li>
<li><p>说一下你的活动经历。说了下大学期间担任班委，负责过班级的财务，然后她笑着问为什么让男生负责财务，因为你数学好才让你负责的吗，囧，我说可能大家是这么认为的吧。研究生负责实验室网络、电脑设备等活动。</p></li>
<li><p>大学期间成绩如何，哪一门学的最好。我说主要是数学吧，她说你能不能讲个case，证明你数学学的好。好吧，从数模竞赛获奖，现在研究算法，已经阿里笔试里面出现的概率等数学题说了下。</p></li>
</ol>


<p>4.读书期间谁对你影响最大，举例说明。举了本科期间的XX同学，研究生期间就直接说带我的boss对我影响最大，好好的夸奖了他一番。O(∩_∩)o</p>

<ol>
<li><p>说一下你在做项目期间，是怎么和其他人合作的，是负责人还是参与者，你和其他人的职责各是什么，怎么分工。还有要是你需要的代码别人没完成，你是怎么和他处理的。能不能举例说明。其中因为一些话不够具体，与她有点分歧，她一定要强调不是感受，是实际怎么操作的。最后回答分工合作的项目是和师兄一起做的，只是参与者，按照分工做好自己的事就没管了，我作为负责人的项目是我一个人做的，没有分工，然后就不再问了。</p></li>
<li><p>说一下你学什么东西的心得最多，其中的亮点在哪里。我说学多线程吧，然后问为什么要学多线程，为什么觉得学了以后收获最多，是和学别的东西比还是怎么比，大概花了多久，你是怎么学的，我说看书，自己学demo测试，有问题查资料，然后运用到项目中。她说每个人不都是这样学的吗，亮点在哪？好吧，半天没明白亮点是什么。过了会，她讲她以前学习东西的时候，做笔记，然后和同学讨论，交流笔记，这样就可以学到更多东西，这是她的亮点。然后我说我写博客啊。技术面试官听到后，速度问你的博客地址，然后瞧进去看了下。很不幸的被看到里面我发的一道TX今年实习生招聘的笔试题，然后问你参加了TX的招聘吗，拿到offer了吗，如实回答拿到了。</p></li>
</ol>


<p>然后HR继续纠结亮点问题，为什么要写博客，我说这样放在网上，无论我在哪里，我想看的时候都能看到，而且可以分享给别人。她说那你怎么不写文档，我说文档只能放在电脑里，不是随时想看就能看，这时她终于不再纠结这个问题了。已经被深深的伤了。中间好像还问到除了学的这些，你还有什么想学的，然后再次回答nginx，和回答一面时差不多的话又说了下，技术面试官点头表示认同，HR然后问为什么要学，回答为了开阔视野，学习成熟的产品有助于个人的进步。总之，当时已感觉这个HR太能折磨人了，我回答的话总觉得她不够满意。唉。</p>

<ol>
<li><p>你以后要做什么方向。好吧，我承认我犯了个错，我说我想做java方向的，因为前两个面试官都问过我以后要是从事java开发，愿不愿意。HR姐姐不乐意了，你是因为阿里java用的多才这么想的吗，你为何要放弃自己擅长的C++，而去用java开发。你不能只看到表面啊，各有各的使用领域啊，如何如何，教育了我一顿。我就频频点头，回答嗯嗯，是我看的太肤浅了，看到网上说现在java用的多才这么想的。好吧，再被伤一次。</p></li>
<li><p>HR姐姐问，TX的offer是什么部门，说了下，那你去TX吗。我赶紧说如果阿里给我offer，我就去阿里。这时技术面试官来了句“他爸妈在杭州，我们有天然优势。”谢谢顶我，我说是的，这是很重要的一点。终于HR不再问了，说没有问题了，问我有没有问题。我说要是录取的话，大概什么时候发offer。她说大概一周内。然后来了句，你很急吗？我赶紧说不急。真是尴尬。再问还有没有问题，我去，有问题也不敢问了啊，就说没有了。然后就结束了这次虐心的面试。最后HR姐姐起身给我开门，好吧，还是感谢下她吧。</p></li>
</ol>


<p>面完二面以后查询的状态就是面试已完成，三面以后也没变化。出来后工作人员叫回去等通知。</p>

<p>五、       总结：</p>

<p>总的来说，写在简历上的东西都会问到，只有你不敢写的，没有不敢问的，写在上面的一定要搞清楚。C++基础，数据结构，STL，多线程这几点被频繁问到，基础一定要扎实才能不被问倒。引用在T派上看到的一句话，TX笔试题出题组长的建议“《C++ primer》《深度探索C++对象模型》这样的书值得看上十遍”，基础有多重要，各位自己体会。</p>

<p>另外还有图像处理方面的文本识别，每个面试官都问到了，可见阿里应该也是有部门专门做这个的。回来后和阿里的师兄了解了下，发现他就是做图像文本识别的，囧。然后推荐大家写博客，当然要是原创的，自己整理的也行，用来技术交流，技术面试官会去网上看你的博客，更好的就是去github上发布自己的源码，如果你有这些，必然会加分不少。没有项目的就去看开源代码，参加开源项目，这也是不错的选择。</p>

<p>最后面试是一个交流的过程，在这个过程中尽量保持清醒的头脑，淡定的状态，即使有问题回答不出标准答案，也不要说不会，尽可能根据自己平时的积累去说一些可能的方法，面试官考察的是你的思维方式和学习能力。再一些技巧，特别是HR，尽量回避自己不确定的东西，我上面那个要说想做java方向的这是个反面教程，有些问题可以回答的抽象点，例如你的规划是怎样的，可以说自己的优势是做技术，三五年内肯定是做技术比较合适，最好是进公司，而且还要进像XXX这样的大平台公司，随便夸该公司一番，提升自己的技术水平，和公司一起进步，至于再往后，我觉得要根据这几年的积累来决定，如何如何。最好不要说我要转行做管理啊什么的，没必要这么说，你能确定你五年后就是个领导了？</p>

<p>最近在T派上有TX的面经征文比赛，需要看面经的可以去T派上看看，百度T派即可看到。本人TX面的感觉有点随意，觉得没太大技术含量，就没写TX的面经。</p>

<p>注：之前看了面经无数，这次是第一次完整的写，当然中间很多问题的回答就直接跳过了，一不小心写了快7000字了，希望对各位有一定帮助，毕竟每个人遇到的面试官都不一样，而且问的问题也是想到什么问什么。总之，基础是最重要的，很多人都认同一句话“没有项目经验，公司可以培养，有经验当然更好；但是公司不会去培养一个基础不好的人”。最后祝各位找到好工作！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pow(x,y)]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/27/pow-x/"/>
    <updated>2014-08-27T23:25:37+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/27/pow-x</id>
    <content type="html"><![CDATA[<blockquote><p>Implement pow(x, n).</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/powx-n/">leetcode express</a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">double</span> <span class="n">pow</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span><span class="p">(</span> <span class="n">x</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span> <span class="n">x</span> <span class="p">,</span> <span class="o">-</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'>        <span class="kt">double</span> <span class="n">num1</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">num2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span> <span class="n">num2</span> <span class="o">*=</span> <span class="n">num1</span><span class="p">;</span>
</span><span class='line'>            <span class="n">num1</span> <span class="o">*=</span> <span class="n">num1</span><span class="p">;</span>
</span><span class='line'>            <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>       <span class="k">return</span> <span class="n">num1</span> <span class="o">*</span> <span class="n">num2</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基础知识回顾]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/27/ji-chu-zhi-shi-hui-gu/"/>
    <updated>2014-08-27T09:43:47+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/27/ji-chu-zhi-shi-hui-gu</id>
    <content type="html"><![CDATA[<!--more-->


<ol>
<li>死锁<br/>
产生死锁的四个必要条件：</li>
<li>互斥条件：一个资源每次只能被一个进程（线程）使用。</li>
<li>请求与保持条件：一个进程（线程）因请求资源而阻塞时，对已获得的资源保持不放</li>
<li>不剥夺条件：进程（线程）已经获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：多个进程（线程）之间形成一种头尾相接的循环等待资源关系。</li>
</ol>


<p>死锁的预防：<br/>
1. <strong>破坏请求保持</strong> 每个进程必须一次性请求它们所需的所有资源，若无法全部获取就等待，知道满足为止，也可以采用事务机制，确保可以回滚，既把获取、释放的资源做成原子性的。这样可以解决某些某些进程无法事先预估自己需要哪些资源<br/>
2. <strong>破坏不可剥夺条件</strong> 一个已占有资源的进程若要再申请新的资源，它必须先释放已占有的资源。若随后再需要这些资源，需要重新申请。<br/>
3. <strong>破坏循环等待条件</strong> 将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作。</p>

<hr />

<p><strong>fork</strong><br/>
在UNIX中，除了PID=0 的交换进程，所有进程都是其他进程使用系统调用fork创建的，这里调用fork创建新进程的进程即为父进程，而穿件的进程为子进程，因而除了进程0以为爱的进程都只有一个父进程，但一个进程可以有多个子进程。如果用户fork一个子进程后exit，子进程的父进程将为init。<br/>
进程在linux中呈树桩结构，init为根节点，其它进程均有父进程。<br/>
fork的作用是复制一个与当前一样的进程。新进程的所有数据（变量，环境变量，程序计数器等）数值都与袁金成一致，但是是一个全新的进程，并作为原进程的子进程。<code>fork函数被调用一次但返回两次</code>。两次返回的唯一区别是<code>子进程中返回0值</code>而<code>父进程中返回子进程的ID</code>。</p>

<blockquote><p><a href="http://music.douban.com/subject/1460454/">转  Linux fork 运行机制  </a></p></blockquote>

<p> 给出如下C程序，在linux下使用gcc编译：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="cp">#include &quot;stdio.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;sys/types.h&quot;</span>
</span><span class='line'><span class="cp">#include &quot;unistd.h&quot;</span>
</span><span class='line'> <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">pid_t</span> <span class="n">pid1</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">pid_t</span> <span class="n">pid2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">pid1</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
</span><span class='line'>    <span class="n">pid2</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;pid1:%d, pid2:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid1</span><span class="p">,</span> <span class="n">pid2</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
要求如下：</p>

<p>已知从这个程序执行到这个程序的所有进程结束这个时间段内，没有其它新进程执行。<br/>
1、请说出执行这个程序后，将一共运行几个进程。<br/>
2、如果其中一个进程的输出结果是“pid1:1001, pid2:1002”，写出其他进程的输出结果（不考虑进程执行顺序）。</p>

<p><strong>预备知识</strong><br/>
1. 进程可以看做程序的一次执行过程。在Linux下，每个进程有唯一的PID标志进程，PID是一个从1到32768得正整数，其中1一般是特殊进程，其它进程从2开始依次编号。当用完32768后，从2重新开始。<br/>
2. linux中有一个叫进程表的结构用来存储当前正在运行的进程。可以使用“ps aux”命令查看所有正在运行的进程。<br/>
3. 进程在linux中呈树状结构，init为根节点，其它进程均有父进程，某进程的父进程就是启动这个进程的进程，这个进程叫做父进程的子进程。<br/>
4. fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。</p>

<p><strong>解题关键</strong></p>

<p><img src="http://pic001.cnblogs.com/images/2010/155795/2010100817495697.gif" alt="" /></p>

<p>上图表示一个含有fork的程序，而fork语句可以看成将程序切为A、B两个部分。然后整个程序会如下运行：</p>

<p>step1、设由shell直接执行程序，生成了进程P。P执行完Part. A的所有代码。</p>

<p>step2、当执行到pid = fork();时，P启动一个进程Q，Q是P的子进程，和P是同一个程序的进程。Q继承P的所有变量、环境变量、程序计数器的当前值。</p>

<p>step3、在P进程中，fork()将Q的PID返回给变量pid，并继续执行Part. B的代码。</p>

<p>step4、在进程Q中，将0赋给pid，并继续执行Part. B的代码。</p>

<p><strong>1、P执行了所有程序，而Q只执行了Part. B，即fork()后面的程序。这是因为Q继承了P的PC-程序计数器
</strong> <br/>
<strong>2、Q继承了fork( )语句执行时当前的环境，而不是程序的初始环境。
</strong><br/>
<strong>3、P中fork( )语句启动子进程Q，并将Q的PID返回，而Q中的fork( )语句不启动新进程，仅将0返回。</strong></p>

<p><strong>解题</strong>
1. 从shell中执行此程序，启动了一个进程，假设这个进程为P0,设其PID为xxx；
2. 当执行到<code>pid1 = fork();</code>时，Po启动的一个子进程P1，由题目知P1的PID为1001，暂且不管P1。
3. Po中得fork返回1001给<code>pid1</code>，继续执行到<code>pid2 = fork();</code>，此时启动另一个新进程，设为P2,由题目知pid2为1002。同样暂且不管P2。
4. P0中的第二个fork返回1002给pid2，继续执行完后续程序，结束。所以，P0的结果为“pid1:1001, pid2:1002”。
5. 再看P2，P2生成时，P0中pid1=1001，所以P2中pid1继承P0的1001，而作为子进程pid2=0。P2从第二个fork后开始执行，结束后输出“pid1:1001, pid2:0”。
6. 接着看P1，P1中第一条fork返回0给pid1，然后接着执行后面的语句。而后面接着的语句是pid2 = fork();执行到这里，P1又产生了一个新进程，设为P3。先不管P3。
7. P1中第二条fork将P3的PID返回给pid2，由预备知识知P3的PID为1003，所以P1的pid2=1003。P1继续执行后续程序，结束，输出“pid1:0, pid2:1003”。
8. P3作为P1的子进程，继承P1中pid1=0，并且第二条fork将0返回给pid2，所以P3最后输出“pid1:0, pid2:0”。
9. 至此，整个执行过程完毕。</p>

<p><strong>所得答案：</strong></p>

<pre><code>  1、一共执行了四个进程。（P0, P1, P2, P3）

  2、另外几个进程的输出分别为：

  pid1:1001, pid2:0

  pid1:0, pid2:1003

  pid1:0, pid2:0  
</code></pre>

<p><img src="http://pic001.cnblogs.com/images/2010/155795/2010100817501849.gif" alt="" /></p>

<h2><strong>raid</strong></h2>

<hr />

<p>其基本思想就是把多个相对便宜的硬盘组合起来,成为一个硬盘阵列组,使性能达到甚 至超过一个价格昂贵、容量巨大的硬盘。根据选择的版本不同,RAID 比单颗硬盘有以下一 个或多个方面的好处:增强资料整合度,增强容错功能,增加处理量或容量。另外,磁碟阵 列对于电脑来说, 看起来就像一个单独的硬盘或逻辑存储单元。  RAID 把多个硬盘组合成为一个逻辑磁区,因此,作业系统只会把它当作一个硬盘。RAID 目前有 0~7 及其中的若干两种组合等十余种不同的等级,不同的 RAID 方法各有其优缺点,<br/>
 RAID 0: 将多个硬盘合为一个,一个损坏,即不可用,<br/>
 RAID 1: 镜像方式存储,利用率仅 &frac12;,但可靠性高</p>

<p> ##堆栈数据代码区 ___
 在UNIX中，从高地址到低地址一次为 stack heap data text</p>

<ul>
<li>栈区(stack) 由编译器自动分配释放，存放函数的参数值，局部变量值等。</li>
<li>堆区 （heap）一般由程序员分配释放，如程序员不释放，程序结束时可能由OS回收。</li>
<li>全局区（静态区 static）全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域data段，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域bss段。程序结束后由系统释放</li>
<li>文字常量区 常量字符串就是放在这里。常量字符串不恩能够修改，否则程序会在运行期崩溃。程序结束后由系统释放。</li>
<li>程序代码区 存放函数体的二进制代码。</li>
</ul>


<h2>c++面向对象语言 </h2>

<hr />

<p><strong>const</strong></p>

<pre><code>int b = 500;const int* a = &amp;b; [1]int const *a = &amp;b; [2]  ￼int* const a = &amp;b; [3]const int* const a = &amp;b; [4]
</code></pre>

<p>如果const位于<code>*</code>左侧，则const就是用来修饰指针所指向的变量，既指针指向为常量；<br/>
如果const位于<code>*</code>右侧，则const就是修饰指针本身，既指针本身是常量。<br/>
还有一个有效的办法是反着读： 如[1] a指向（<code>*</code>）int型常量；[2]a指向(<code>*</code>)常量是int型；[3]a是常量指针指向(<code>*</code>)int型变量; [4]a是常量指针指向(<code>*</code>)int型常量</p>

<h2>深拷贝 和 浅拷贝</h2>

<hr />

<p>浅拷贝：被复制的对象的所有变量都含有原来对象相同的值，而其所有的对其他对象的引用都仍然指向原来的对象。浅拷贝复制时，将这个对象的值字段和引用字段（均为非晶态字段）全部复制过去，获得了这个对象的值和地址。即：当其中一个对象的引用字段所指向的地址中的变量变化时，所有浅拷贝对象中的该引用字段都会发生变化。<br/>
深拷贝：被复制对象会讲所有非引用类型的字段复制给新对象，同事将引用类型所指向地址中存储的对象复制给新的对象。深拷贝与浅拷贝的具备在于对引用类型的对待上，一个是复制地址（浅拷贝）。另一个是复制地址指向位置的数据(深拷贝)。</p>

<h2>c/c++可变参数的实现</h2>

<hr />

<ol>
<li>可变参数的原理</li>
<li>可变长书的设计</li>
<li>可变参数的实现</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[next_permutation]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/26/next-permutation/"/>
    <updated>2014-08-26T13:51:45+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/26/next-permutation</id>
    <content type="html"><![CDATA[<blockquote><p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.<br/>
If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).<br/>
The replacement must be in-place, do not allocate extra memory.<br/>
Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</p></blockquote>

<pre><code> 1,2,3 → 1,3,2 
 3,2,1 → 1,2,3 
 1,1,5 → 1,5,1
</code></pre>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/next-permutation/">leetcode express</a></p>

<p><em>思路</em></p>

<ol>
<li>从后向前扫描 <code>vector&lt;int&gt; num</code>，寻找后一个数大于前一个数的位置，标记前一个数的index 为 <code>i</code>。</li>
<li>再从后面开始扫描，寻找第一个大于下标为<code>num[i]</code>的数（必然存在，主意一定是大于没有等于符号），标记符合条件的下标为<code>j</code>,交换<code>num[i]</code> ,<code>num[j]</code>。</li>
<li>将<code>index[i]</code>后的全部数字逆置，得到结果。</li>
</ol>


<p><strong>exception</strong></p>

<ul>
<li>若当前数字排序已经是能表示的最大数字，所以符合条件的下一个字典序为所有排列中最小的数字</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">void</span> <span class="n">nextPermutation</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">num</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">,</span> <span class="n">ii</span><span class="o">--</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">num</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>                <span class="k">while</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span><span class='line'>                    <span class="n">j</span><span class="o">--</span><span class="p">;</span>
</span><span class='line'>                <span class="n">swap</span><span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">num</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span><span class='line'>                <span class="n">reverse</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">ii</span><span class="p">,</span><span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class='line'>                <span class="k">return</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">reverse</span><span class="p">(</span><span class="n">num</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">num</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存相关]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/25/nei-cun-xiang-guan/"/>
    <updated>2014-08-25T22:24:17+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/25/nei-cun-xiang-guan</id>
    <content type="html"><![CDATA[<!--more-->


<h3>1. 内存对齐：</h3>

<p> 编译器会自动进行成员变量的对齐，以提高运算效率。缺省情况下，编译器为结构体的每个成员按其自然对界（natural alignment）条件分配内存。每个成员按照它们被声明的顺序在内存中存储，第一个成员的地址和整个结构体的地址相同。<br/>
 为什么要进行内存对齐呢，原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；然而，对齐的内存访问仅需要一次访问。所以为了内存的有效利用，我们有必要在定义结构体前考虑下成员的顺序。字，双字，和四字在自然边界上不需要在内存中对齐。（对字，双字，和四字来说，自然边界分别是偶数地址，可以被4 整除的地址，和可以被8 整除的地址。）
 除此之外我们还可以利用#pragma pack（）来改变编译器的默认对齐方式。使用伪指令#pragma pack (n)，编译器将按照n个字节对齐；使用伪指令#pragma pack ()，取消自定义字节对齐方式。注意：如果
/#pragma pack (n)中指定的n大于结构体中最大成员的size，则其不起作用，结构体仍然按照size最大的成员进行对界。其对齐的规则是,每个成员按其类型的对齐参数(通常是这个类型的大小)和指定对齐参数
(这里是n 字节)中较小的一个对齐，即：min( n, sizeof( item ))</p>

<h3>2. struct与class的区别:</h3>

<p>在C++中，struct与class的区别有两点，一是struct中成员变量和函数的默认访问权限为public，而class的为private。二是由于C++中struct兼容了C中的struct的所有特性，可以定义的时候直接
以{ }对其成员变量赋初值，而class则不能。</p>

<h3>cpu与外设之间的数据传送方式</h3>

<ol>
<li><p>程序传送方式</p>

<ul>
<li>程序查询方式分为无条件传送方式和查询方式（条件传送方式）两种。

<ul>
<li><p>微机系统中的一些简单的外设，如开关、继电器、数码管、发光二极管等，在它们工作时，可以认为输入设备已随时准备好向CPU提供数据，而输出设备也随时准备好接收CPU送来的数据，这样，在CPU需要同外设交换信息时，就能够用IN或OUT指令直接对这些外设进行输入/输出操作。由于在这种方式下CPU对外设进行输入/输出操作时无需考虑外设的状态，故称之为无条件传送方式。</p></li>
<li><p>查询传送也称为条件传送，是指在执行输入指令（IN）或输出指令（OUT）前，要先查询相应设备的状态，当输入设备处于准备好状态、输出设备处于空闲状态时，CPU才执行输入/输出指令与外设交换信息。为此，接口电路中既要有数据端口，还要有状态端口。</p>

<p>1．CPU从接口中读取状态字；<br/>
2．CPU检测相应的状态位是否满足“就绪”条件；<br/>
3．如果不满足，则重复1、2步；若外设已处于“就绪”状态，则传送数据。</p></li>
</ul>
</li>
</ul>
</li>
<li><p>中断传送方式</p>

<ul>
<li>中断传送方式是指当外设需要与CPU进行信息交换时，由外设向CPU发出请求信号，使CPU暂停正在执行的程序，转去执行数据的输入/输出操作，数据传送结束后，CPU再继续执行被暂停的程序。</li>
</ul>
</li>
<li><p>直接存储器存取（DMA）</p>

<ul>
<li>DMA传送方式是在存储器和外设之间、存储器和存储器之间直接进行数据传送(如磁盘与内存间交换数据、高速数据采集、内存和内存间的高速数据块传送等)，传送过程无需CPU介入，这样，在传送时就不必进行保护现场等一系列额外操作，传输速度基本取决于存储器和外设的速度。DMA传送方式需要一个专用接口芯片DMA控制器（DMAC）对传送过程加以控制和管理。进行DMA传送期间，CPU放弃总线控制权，将系统总线交由DMAC控制，由DMAC发出地址及读/写信号来实现高速数据传输。传送结束后DMAC再将总线控制权交还给CPU。</li>
</ul>
</li>
</ol>


<h3>map reduce</h3>

<p><img src="http://www.opensourceforu.com/wp-content/uploads/2011/03/MapReduce.jpg" alt="" /></p>

<h3>数据库</h3>

<ol>
<li>事务的属性包括四大类 ACID <code>atomic 原子性</code> <code>consistency 一致性</code> <code>isolation 隔离性</code> <code>durability 持久性</code></li>
<li>查询 student 表 第5到10条数据 select * from student limit 5,10</li>
</ol>


<p>MYSQL 操作 出处：<a href="http://jilili.blog.51cto.com/6617089/1190014">http://jilili.blog.51cto.com/6617089/1190014</a><br/>
3、修改表
ALTER TABLE tb_name;     <br/>
mysql>alter table students change course Course varchar(100) after name;  <br/>
mysql>alter table students add course varchar(100);     <br/>
向表中插入数据</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>insert into tb_name （col，col2，....) values (val1,val2,....）;      
</span><span class='line'>insert into tutors （Tname，Gender，Age） values ('jerry','M',24);  -----批量插入方式
</span><span class='line'>insert into tutors set Tname='Tom',Genser='F',Age=30;            -----只能实现单个字段</span></code></pre></td></tr></table></div></figure>


<p> <br/>
插入</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>insert into tutors （Tname,Gender,Age) select Name,Genser,Age from students where Age &gt;=20  
</span><span class='line'>select * from tutors order by TID desc limit 1;          -----查看降序的第一行  
</span><span class='line'>select last_insert_ID（）;      -----查询插入的最后一个序列号 </span></code></pre></td></tr></table></div></figure>


<p> <br/>
更改数据库</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>UPDATE tb_name SET column=value where   
</span><span class='line'>mysql&gt;update students set Course='wg' where Name='j'; ' -----更改j的课程为wg   </span></code></pre></td></tr></table></div></figure>


<p>`
删除表中的某一字段</p>

<p><code>DELETE FROM students  WHERE Course='';</code></p>

<p>6、select语句练习</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>select distict Gender from students;         ------相同的内容只显示一次    
</span><span class='line'> 
</span><span class='line'>查找年龄大于20的同学并且按降序排列:   
</span><span class='line'>select Name,Age from students where Age&gt;20 order by Age desc;    
</span><span class='line'>年龄大于等于20并且是男性的同学:     
</span><span class='line'>select Name from students where Age&gt;20 and Gender='M';  
</span><span class='line'>年龄不大于20的同学:  
</span><span class='line'>select Name,Age,Gender from students where not Age&gt;20;    
</span><span class='line'>小于等于20的女同学:  
</span><span class='line'>select Name,Age,Gender from students where not （Age&gt;20 or Gender=‘M’）;  
</span><span class='line'>年龄在（21-24）之间的同学(以下两种方式）：  
</span><span class='line'>select Name，Age from students where Age&gt;20 and Age&lt;25;  
</span><span class='line'>select Name，Age from students where Age between 20 and 25;   
</span><span class='line'>显示以Y开头的名称（这里限定了姓名的长度）("_"表示任意单个字符):   
</span><span class='line'>select Name from students where Name like 'Y___';  
</span><span class='line'>显示以Y开头的姓名：   
</span><span class='line'>`select Name from students where Name like 'Y%';  `    
</span><span class='line'>名称中含有ing的名称（“%”表示任意长度的任意字符):    
</span><span class='line'>`select Name from students where Name like '%ing%';  `     
</span><span class='line'>显示以M或N或Y开头的名字（支持正则表达式）:  
</span><span class='line'>`select Name from students where Name rlike '^[MNY].*$'; `    
</span><span class='line'>显示年龄是18、20、25的同学：  
</span><span class='line'>`select Name from students where Age IN （18,20,25）; `     
</span><span class='line'>显示挑选课程号(CID1)为空的同学：   
</span><span class='line'>`select Name from students where CID1 is null; `   
</span><span class='line'>把查询后的结果进行降序排序（ASC升序，desc降序）   
</span><span class='line'>`select Name,CID1 from students where CID1 is not null order by CID1 desc;  ` 
</span><span class='line'>显示查询的Name表头名变为name    
</span><span class='line'>`select Name AS Student_Name from students;  `   
</span><span class='line'>隔两行数据向后取三行数据：  
</span><span class='line'>`select Name from students limit 2,3;  ` 
</span><span class='line'>所有同学的平均年龄:  
</span><span class='line'>`select AVG（age） from students;  `  
</span><span class='line'>显示年龄最大的同学：  
</span><span class='line'>select MAX（age） from students;   
</span><span class='line'>显示年龄最小的同学：   
</span><span class='line'>`select MIN（age） from students;  `  
</span><span class='line'>显示所有同学的年龄总和：   
</span><span class='line'>`select SUM（age） from students;  `  
</span><span class='line'>显示所有同学的个数：    
</span><span class='line'>`select count（age） from students; `   
</span><span class='line'>显示所有男同学的平均年龄：  
</span><span class='line'>`select AVG（age） from students where Gender=’M‘;`    
</span><span class='line'>显示所有女同学的平均年龄：   
</span><span class='line'>`select AVG（age） from students where Gender=’F‘; `  
</span><span class='line'>显示男女同学的平均年龄：  
</span><span class='line'>`select Gender,avg(age) from students group by Gender; `  
</span><span class='line'>显示选修CID1的同学   
</span><span class='line'>``select count(CID1) AS  Persons,CID1 from students group by CID1;`  
</span><span class='line'>显示选修人数大于2的课程：   
</span><span class='line'>``select count(CID1) AS  Persons,CID1 from students group by CID1 having Persons&gt;=2;``
</span><span class='line'> 
</span><span class='line'>**多表查询**   
</span><span class='line'>每位同学及其他所学习的课程名称（以下四种方式）  </span></code></pre></td></tr></table></div></figure>


<p>
select students.Name,courses.Cname from students，courses where   students.CID1=courses.CID;<br/>
select s.Name,c.Cname from students AS s,courses AS c where s.CID1=c.CID; <br/>
select s.Name,c.Cname from students AS s left jion courses AS c on s.CID1=c.CID;(左连接）
select s.Name,c.Cname from students AS s right jion courses AS c on s.CID1=c.CID;（右连接)</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>显示各个同学与他相对应的导师：   
</span><span class='line'>`select c.Name as student,s.Name as teacher from students as s,students as c where
</span><span class='line'> s.SID=c.TID;  ` 
</span><span class='line'>显示每一位老师及其所教授的课程；没有教授的课程保持为NULL:    
</span><span class='line'>`select t.Tname,c.Cname from tutors as t left join courses as c on t.TID=c.TID; `
</span><span class='line'>显示每一个课程及其相关的老师，没有老师教授的课程将其老师显示为空:   
</span><span class='line'>`select t.Tname,c.Cname from tutors as t right jion courses as c on t.TID=c.TID; `
</span><span class='line'>显示每位同学CID1课程的课程名及其讲授了相关课程的老师的名称：  </span></code></pre></td></tr></table></div></figure>


<p>sql
select Name,Cname,Tname from students,courses,tutors where students.CID1=courses.CID<br/>
and courses.TID=tutors.TID;</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>查看同学的成绩及姓名，并且按升序排列：  </span></code></pre></td></tr></table></div></figure>


<p> sql
select students.Name,scores.Score from students,scores where students.SID=scores.SID<br/>
order by scores.Score desc;
&#8220;`</p>

<p><strong>子查询</strong> <br/>
挑选出courses表中没有被students中的CID2学习的课程的课程名称：<br/>
<code>select Cname from courses where CID not IN (select CID2 from students where  
CID2 is not null);</code>
挑选出没有教授任何课程的老师，每个老师及其所教授课程的对应关系在courses表中： <br/>
<code>select Tname from tutors where TID not in (select distinct TID from courses);</code>
找出students表中CID1有两个或两个以上同学学习了的同一个门课程的课程名称： <br/>
<code>select Cname from courses where CID in (select CID1 from students group by CID1
 having count(CID1) &gt;=2);</code>
年龄大于平均年龄的同学：(使用子查询时，子查询只能返回单个值）：<br/>
<code>select Name,Age from students where Age &gt; (select avg(age) from students); </code>
查询学生和老师各自的年龄并写在一个表中： <br/>
<code>(select Name，Age from students) union (select Tname，Age from tutors);</code></p>

<h3>进程</h3>

<p>进程通信<br/>
windows的进程间的通信方式有:<br/>
1.文件映射；2. 共享内存（是文件映射的一种特殊情况）；3.邮件槽（mailslot）（点对点消息队列）; 4.匿名管道；5；命名管道； 6. 剪贴板；7.动态数据交换；8.对象链接与嵌入；9.远程过程调用；10.动态链接库；11.socket；12.WM_COPYDATA .<br/>
linux进程间通信的方式有：1.管道 2.信号量 3.共享内存 4.消息队列 5.套接字 6.信号<br/>
windows和linux共有的进程间通信方式：1. 消息（linux中叫做信号） 2. 共享内存  3. 邮槽  4. 管道   5.socket</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique Binary Search Trees]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/25/unique-binary-search-trees/"/>
    <updated>2014-08-25T20:17:26+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/25/unique-binary-search-trees</id>
    <content type="html"><![CDATA[<blockquote><p>Given n, how many structurally unique BST&rsquo;s (binary search trees) that store values 1&hellip;n?</p>

<p>For example,</p>

<p>Given n = 3, there are a total of 5 unique BST&rsquo;s.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/unique-binary-search-trees/">leetcode express</a></p>

<p><em>思路</em><br/>
二叉搜索树分为左子树，根，右子树。而每一个左子树又可继续划分为以上结构。同理右子树也可以进行同样的划分。使用一个数组来记录n个节点的二叉搜索树有多少种。后面使用时直接查询即可。</p>

<p>依次把每个节点作为根节点，左边节点作为左子树，右边节点作为右子树，那么总的数目等于左子树数目*右子树数目。</p>

<figure class='code'><figcaption><span>DP</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">numTrees</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>        <span class="n">memset</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">));</span>
</span><span class='line'>        <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>                <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>实际上只需计算前半部分作为根节点的树的数目，然后乘以2（奇数节点还要加上中间节点作为根的二叉搜索树的数目）</p>

<figure class='code'><figcaption><span>只计算前半段划分</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">numTrees</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>        <span class="n">memset</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">));</span>
</span><span class='line'>        <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">i</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">tmp</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="mh">0x1</span><span class="p">)</span>
</span><span class='line'>                <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">*</span> <span class="n">array</span><span class="p">[</span><span class="n">tmp</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[哈希表相关]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/25/ha-xi-biao-xiang-guan/"/>
    <updated>2014-08-25T16:04:35+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/25/ha-xi-biao-xiang-guan</id>
    <content type="html"><![CDATA[<blockquote><p>先从面试题说起：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。</p>

<p>假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。</p></blockquote>

<h1>哈希表 （Hash table）</h1>

<p>hash table 是根据关键码值直接访问的数据结构（key value）。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>

<p>hashtable的做法就是把key通过固定的哈希函数转换成一个整型数字，然后将该数字对数组长度取余，取余结果当做key的数组下表，将value存储在下标对应的数组空间里。 使用哈希表进行查询的时候，再次使用哈希函数将key转换为对应的数组下标，并定位到该空间获取value，利用数组的快速定位的性能来进行数据定位。</p>

<p>问题解析：</p>

<p>要统计最热门查询，首先就是要统计每个Query出现的次数，然后根据统计结果，找出Top 10.</p>

<h3>1. Query统计</h3>

<p>Query统计有两种方法：</p>

<ul>
<li><p>直接排序</p>

<ol>
<li>首先对日志中所有的Query排序，再遍历排序后的Query，统计每个Query出现的次数。题目中要求内存不超过1G，一千万条记录每条记录255Byte，大概需要2G多内存。不满足要求。当数据量较大内存无法装下时，可以采用外排序的方法，这里了采用归并排序。时间复杂度为O（NlgN）。</li>
<li>排序后再对已经有序的Query文件进行表里，统计每个Query出现的次数，写入文件中，时间复杂度O（n）。</li>
<li>综合分析一下，排序的时间复杂度是O(NlgN)，而遍历的时间复杂度是O(N)，因此该算法的总体时间复杂度就是O(N+NlgN)=O（NlgN）。</li>
</ol>
</li>
<li><p>Hash Table法</p>

<ol>
<li>题目中说明如遇Query重复读较高，实际只有300万的Query，每个Query255Byte，实际占用内存不超过<code>255*3M</code>，1G内存完全够用，因此可以把他们都放在内存中，现在只需要一个合适的数据结构，来降低查询所用的时间，Hash Table是首选，因为Hash Table的时间复杂度几乎为 <code>O(1)</code>。</li>
<li>维护一个Key为uQuery字串，Value为该Query出现的次数的Hash Table，每次读取一个Query，如果该字串不在Table中，就加入该字串，并将Value付志伟1；如果该字串在Table中，那么该字串的统计次数加一。最终在<code>O(n)</code>的时间复杂度完成了该海量数据的处理。</li>
<li>与算法1比时间复杂度提高了一个数量级，而且该算法复杂度只需要对数据文件进行一次IO操作，而算法1的IO操作较多，因此算法2更佳。</li>
</ol>
</li>
</ul>


<h3>2. 找出Top 10</h3>

<ul>
<li>算法一 普通排序 <br/>
我想对于排序算法大家都已经不陌生了，这里不在赘述，我们要注意的是排序算法的时间复杂度是NlgN，在本题目中，三百万条记录，用1G内存是可以存下的。</li>
<li>算法二 部分排序<br/>
题目要求是求出Top 10，因此我们没有必要对所有的Query都进行排序，我们只需要维护一个10个大小的数组，初始化放入10个Query，按照每个Query的统计次数由大到小排序，然后遍历这300万条记录，每读一条记录就和数组最后一个Query对比，如果小于这个Query，那么继续遍历，否则，将数组中最后一条数据淘汰，加入当前的Query。最后当所有的数据都遍历完毕之后，那么这个数组中的10个Query便是我们要找的Top10了。这样，算法的最坏时间复杂度是 <code>O(N*K)</code>， 其中K是指top多少。</li>
<li>算法三 堆  <br/>
在算法二中，我们已经将时间复杂度由NlogN优化到NK。每次比较完成之后，需要把元素插入到线性表中，而且采用的时顺序比较，如果采用二分查找的话，操作的复杂度就降低到logK，不过数据移动次数没有什么变化。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[two sum]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/25/two-sum/"/>
    <updated>2014-08-25T11:08:14+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/25/two-sum</id>
    <content type="html"><![CDATA[<blockquote><p>Given an array of integers, find two numbers such that they add up to a specific target number.</p>

<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>

<p>You may assume that each input would have exactly one solution.</p>

<p>  Input: numbers={2, 7, 11, 15}, target=9</p>

<p>  Output: index1=1, index2=2</p></blockquote>

<!--more-->


<p><em>思路</em></p>

<ol>
<li>用map存储整个vector，用vector中每个元素的值做pair的key，元素的index作为pair值，插入到map中</li>
<li>遍历数组时，从图中查找target-num[i]，利用图来降低时间复杂度 O(logN);</li>
</ol>


<figure class='code'><figcaption><span>时间复杂度 O(n), 空间复杂度O(n) </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">numbers</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">nums</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">for</span><span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">target</span> <span class="o">-</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>            <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">index1</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>                <span class="kt">int</span> <span class="n">index2</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
</span><span class='line'>                <span class="k">if</span><span class="p">(</span><span class="n">index1</span><span class="o">&lt;</span> <span class="n">index2</span><span class="p">)</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span>
</span><span class='line'>                    <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">index2</span><span class="p">);</span>
</span><span class='line'>                    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">index1</span> <span class="o">&gt;</span> <span class="n">index2</span><span class="p">)</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">index2</span><span class="p">);</span>
</span><span class='line'>                    <span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">index1</span><span class="p">);</span>
</span><span class='line'>                    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><em>另一种解法</em></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">twoSum</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">numbers</span><span class="p">,</span> <span class="kt">int</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>        <span class="n">assert</span><span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">mapping</span><span class="p">;</span>
</span><span class='line'>        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">mul</span><span class="p">(</span><span class="n">len</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">mul</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">*</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">mapping</span><span class="p">[</span><span class="n">mul</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>              <span class="c1">// 排除 numbers[i] == target/2 的情况</span>
</span><span class='line'>                <span class="k">if</span><span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="n">mul</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">mul</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
</span><span class='line'>                    <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>                    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">mapping</span><span class="p">[</span><span class="n">mul</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Common Prefix]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/22/longest-common-prefix/"/>
    <updated>2014-08-22T20:26:21+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/22/longest-common-prefix</id>
    <content type="html"><![CDATA[<blockquote><p>Write a function to find the longest common prefix string amongst an array of strings.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/longest-common-prefix/">leetcode express</a></p>

<p><em>思路</em></p>

<ul>
<li>从vector中找到长度最短的string，作为prefix</li>
<li>依次比较每个字串，如果前缀不同，则将prefix的最后一个字符删去，继续比较</li>
</ul>


<figure class='code'><figcaption><span>时间复杂度 O(mn),空间复杂度O(1)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="n">string</span> <span class="n">longestCommonPrefix</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">strs</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">strs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//find the shortest string&#39;s index</span>
</span><span class='line'>        <span class="c1">//to prevent performance degradation</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">_min_len_</span> <span class="o">=</span> <span class="n">strs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">_min_len_index_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">_min_len_</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">_min_len_</span> <span class="o">=</span> <span class="n">strs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span>
</span><span class='line'>                <span class="n">_min_len_index_</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>        <span class="n">string</span> <span class="n">prefix</span> <span class="o">=</span> <span class="n">strs</span><span class="p">[</span><span class="n">_min_len_index_</span><span class="p">];</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">strs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">find</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">prefix</span> <span class="o">=</span> <span class="n">prefix</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">prefix</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'>                <span class="o">--</span><span class="n">i</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">prefix</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Palindrome Number]]></title>
    <link href="http://michaelpassion.github.io/blog/2014/08/22/palindrome-number/"/>
    <updated>2014-08-22T18:59:43+08:00</updated>
    <id>http://michaelpassion.github.io/blog/2014/08/22/palindrome-number</id>
    <content type="html"><![CDATA[<blockquote><p>Determine whether an integer is a palindrome. Do this without extra space.</p>

<p>Some hints:</p>

<p>Could negative integers be palindromes? (ie, -1)</p>

<p>If you are thinking of converting the integer to string, note the restriction of using extra space.</p>

<p>You could also try reversing an integer. However, if you have solved the problem &ldquo;Reverse Integer&rdquo;, you know that the reversed integer might overflow. How would you handle such case?</p>

<p>There is a more generic way of solving this problem.</p></blockquote>

<!--more-->


<p><a href="https://oj.leetcode.com/problems/palindrome-number/">leetcode express</a></p>

<p>根据提示知：</p>

<ul>
<li>负数肯定不是回文数字</li>
<li>如果将数字转换为字符串，则使用了额外空间，不符合题目要求</li>
<li>每次选取最高位和最低位比较，如果不同，则返回false</li>
<li>如果最高位和最低位相同，则将该数字转换为减去最高位和最低位的数字(外观上，实际需要数学操作)</li>
</ul>


<figure class='code'><figcaption><span>时间复杂度 O(n), 空间复杂度 O(1)</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='c++'><span class='line'><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>    <span class="kt">bool</span> <span class="n">isPalindrome</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">int</span> <span class="n">div</span> <span class="o">=</span><span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="k">while</span><span class="p">(</span> <span class="n">x</span> <span class="o">/</span> <span class="n">div</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">div</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">while</span><span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">div</span><span class="p">;</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>            <span class="k">if</span><span class="p">(</span><span class="n">l</span> <span class="o">!=</span> <span class="n">r</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
</span><span class='line'>            <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">div</span><span class="p">)</span> <span class="o">/</span><span class="mi">10</span><span class="p">;</span>
</span><span class='line'>            <span class="n">div</span> <span class="o">/=</span> <span class="mi">100</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>
